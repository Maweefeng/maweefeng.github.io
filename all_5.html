<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
  
  
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="%E7%94%B5%E5%BD%B1.html">电影</a></li>
        
            <li><a href="%E5%85%B6%E5%AE%83.html">其它</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="16076509805505.html">
                
                  <h1>This package has installed:</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<pre><code class="language-text">•   Node.js v10.14.1 to /usr/local/bin/node
•   npm v6.4.1 to /usr/local/bin/npm
</code></pre>

<p>Make sure that /usr/local/bin is in your $PATH.</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/12/11</span>
                    
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509805549.html">
                
                  <h1>hexo</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>sudo -s 终端全部使用管理员的方式运行</p>

<h3 id="toc_0">Init a new project</h3>

<pre><code class="language-bash">$ hexo init
</code></pre>

<h3 id="toc_1">Create a new post</h3>

<pre><code class="language-bash">$ hexo new &quot;My New Post&quot;
</code></pre>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>

<h3 id="toc_2">Create a new draft</h3>

<pre><code class="language-bash">$ hexo new draft &quot;draft Post&quot;
</code></pre>

<h3 id="toc_3">Run server</h3>

<pre><code class="language-bash">$ hexo server
</code></pre>

<p>如果端口被占用了 可以使用-p 重设端口</p>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>

<h3 id="toc_4">Generate static files</h3>

<pre><code class="language-bash">$ hexo generate
</code></pre>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>

<h3 id="toc_5">Deploy to remote sites</h3>

<pre><code class="language-bash">$ hexo deploy
</code></pre>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>

<h3 id="toc_6">生成纯页面</h3>

<pre><code class="language-bash">$ hexo new page &quot;pageName&quot;
</code></pre>

<p>在yml配置文件中可以添加这行代码</p>

<pre><code class="language-text">#包含和剔除
include:
  - .nojekyll
exclude:
  - .DS_Store

</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/12/11</span>
                    
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509805590.html">
                
                  <h1>iOS开发代码规范</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>针对我的开发经验ViewController应该是这样的。</p>

<pre><code class="language-text">#pragma mark - Life Cycle|生命周期
#pragma mark - UITableViewDataSource and UITableViewDelegate|主要是一些代理的方法
#pragma mark - Private Method|私有方法（内部可调用）
#pragma mark - Public  Method|公有方法
#pragma mark - Set &amp; Get|getter 和 setter方法
#pragma mark - Notification|接收通知之后执行的方法
#pragma mark - Event|一些视图的点击事件 比如button
#pragma mark - DelegeteHandler|代理的实现时间
</code></pre>

<h2 id="toc_0">1️⃣代码命名基础</h2>

<h3 id="toc_1">①一般原则</h3>

<ul>
<li><p>明晰</p>
<ul>
<li><p>尽可能保持清晰和简洁是件好事，但由于简洁，清晰度不应受到影响：</p>
<p>比如<code>insertObject:atIndex:</code>比较清晰，而<code>insert:at:</code>却不知道发生了什么。</p></li>
<li><p>一般来说，不要缩写事物的名称。把它们拼出来，即使它们很长：</p>
<p>比如<code>setBackgroundColor:</code>和<code>setBkgdColor:</code><br/>
有些缩写是很常见且取得了各方面的共识，所以你可以继续使用它们。<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/APIAbbreviations.html#//apple_ref/doc/uid/20001285-BCIHCGAE">可接受的缩写和缩略语</a></p></li>
</ul></li>
<li><p>一致性</p>
<ul>
<li>尝试在整个Cocoa编程接口中使用一致的名称。如果您不确定，请浏览当前头文件或参考文档以获取先例。</li>
<li><p>当你有一个方法应该利用多态性的类时，一致性尤为重要。在不同类中执行相同操作的方法应具有相同的名称。</p>
<table>
<thead>
<tr>
<th>code</th>
<th>comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (NSInteger)tag</td>
<td>定义中NSView，NSCell，NSControl。</td>
</tr>
<tr>
<td>- (void)setStringValue:(NSString *)</td>
<td>定义在许多Cocoa类中。</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul>

<h3 id="toc_2">②前缀</h3>

<p>前缀是编程接口中名称的重要部分。它们区分了软件的功能区域。前缀可防止第三方开发人员定义的符号与Apple定义的符号（以及Apple自己的框架中的符号之间）发生冲突。</p>

<ul>
<li><p>前缀具有规定的格式。它由两个或三个大写字母组成，不使用下划线或“子前缀”。以下是一些示例：</p></li>
<li><p>在命名类，协议，函数，常量和typedef结构时使用前缀。千要不能在命名方法时，使用前缀; 方法存在于由定义它们的类创建的名称空间中。另外，不要使用前缀来命名结构体的字段。</p></li>
</ul>

<h2 id="toc_3">2️⃣命名方法</h2>

<h3 id="toc_4">①通用规则</h3>

<p>在命名方法时，请记住以下几条一般准则：</p>

<ul>
<li>使用小写字母开始名称，并将嵌入单词的第一个字母大写。不要使用前缀。</li>
<li>对于表示对象采取的操作的方法，使用动词开始名称(禁止使用“do”或“does”)。</li>
<li><p>如果方法返回接收者的属性，则在属性后面命名方法。除非间接返回一个或多个值，否则不必使用<code>get</code>。</p>
<table>
<thead>
<tr>
<th>code</th>
<th>comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (NSSize)cellSize;</td>
<td>正确</td>
</tr>
<tr>
<td>- (NSSize)getCellSize;</td>
<td>错误</td>
</tr>
</tbody>
</table></li>
<li><p>在所有参数之前使用关键字</p>
<table>
<thead>
<tr>
<th>code</th>
<th>comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (void)sendAction:(SEL)aSelector toObject:(id)anObject forAllCells:(BOOL)flag;</td>
<td>正确</td>
</tr>
<tr>
<td>- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;</td>
<td>错误</td>
</tr>
</tbody>
</table></li>
<li><p>在参数之前创建单词描述参数。</p>
<table>
<thead>
<tr>
<th>code</th>
<th>comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (id)viewWithTag:(NSInteger)aTag;</td>
<td>正确</td>
</tr>
<tr>
<td>- (id)taggedView:(int)aTag;</td>
<td>错误</td>
</tr>
</tbody>
</table></li>
<li><p>在创建比继承方法更具体的方法时，在现有方法的末尾添加新关键字。</p>
<table>
<thead>
<tr>
<th>code</th>
<th>comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (id)initWithFrame:(CGRect)frameRect;</td>
<td>初始化方法</td>
</tr>
<tr>
<td>- (id)initWithFrame:(CGRect)frameRect backgroundColor:(UIColor*)backgroundColor;</td>
<td>自定义初始化方法</td>
</tr>
</tbody>
</table></li>
<li><p>不要使用“and”来链接作为接收者属性的关键字。</p>
<table>
<thead>
<tr>
<th>code</th>
<th>comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (int)runModalForDirectory:(NSString *)path file:(NSString *) name types:(NSArray *)fileTypes;</td>
<td>正确</td>
</tr>
<tr>
<td>- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;</td>
<td>错误</td>
</tr>
</tbody>
</table></li>
<li><p>如果该方法描述了两个单独的操作，请使用“和”链接它们。</p>
<table>
<thead>
<tr>
<th>- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;</th>
<th>NSWorkspace</th>
</tr>
</thead>
<tbody>
</tbody>
</table></li>
</ul>

<h3 id="toc_5">②访问方法</h3>

<p>访问器方法是设置和返回对象属性值的方法</p>

<ul>
<li><p>如果属性表示为名词，则格式为：</p>
<pre><code class="language-text">- (type)noun;
- (void)setNoun：(type)aNoun ;
</code></pre></li>
<li><p>如果属性表示为形容词，则格式为：</p>
<p>在声明属性的时候可以这么写<br/>
<code>@property(nonatomic,assign,getter=isAdjective)BOOL Adjective;</code></p>
<pre><code class="language-text">- (BOOL)isAdjective;
- (void)setAdjective:(BOOL)flag;
</code></pre></li>
<li><p>如果属性表示为动词，则格式为：</p>
<pre><code class="language-text">- (BOOL)verbObject;
- (void)setVerbObject:(BOOL)flag;
</code></pre></li>
<li><p>不要使用分词将动词转换为形容词：</p>
<table>
<thead>
<tr>
<th>- (void)setAcceptsGlyphInfo:(BOOL)flag;</th>
<th>对</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (BOOL)acceptsGlyphInfo;</td>
<td>对</td>
</tr>
<tr>
<td>- (void)setGlyphInfoAccepted:(BOOL)flag;</td>
<td>错</td>
</tr>
<tr>
<td>- (BOOL)glyphInfoAccepted;</td>
<td>错</td>
</tr>
</tbody>
</table></li>
<li><p>可以使用模态动词（动词前面加上“can”，“should”，“will”等）来澄清含义，但不要使用“do”或“does”。</p>
<table>
<thead>
<tr>
<th>- (void)setCanHide:(BOOL)flag;</th>
<th>对</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (BOOL)canHide;</td>
<td>对</td>
</tr>
<tr>
<td>- (void)setShouldCloseDocument:(BOOL)flag;</td>
<td>对</td>
</tr>
<tr>
<td>- (BOOL)shouldCloseDocument;</td>
<td>对</td>
</tr>
<tr>
<td>- (void)setDoesAcceptGlyphInfo:(BOOL)flag;</td>
<td>错</td>
</tr>
<tr>
<td>- (BOOL)doesAcceptGlyphInfo;</td>
<td>错</td>
</tr>
</tbody>
</table></li>
<li><p>仅对间接返回对象和值的方法使用“get”。并且当需要返回多个项目时，才应将此表单用于方法。</p>
<table>
<thead>
<tr>
<th>- (void)getLineDash:(float *)pattern count:(int *)count phase:(float *)phase;</th>
<th>NSBezierPath</th>
</tr>
</thead>
<tbody>
</tbody>
</table></li>
</ul>

<h3 id="toc_6">③代理方法</h3>

<p>委托方法（或委托方法）是在某些事件发生时对象在其委托中调用的方法（如果委托实现它们）。它们具有独特的形式，同样适用于在对象的数据源中调用的方法：</p>

<ul>
<li><p>方法的开始使用通过标识发送消息的对象的类(类名省略前缀，第一个字母为小写)：</p>
<pre><code class="language-text">- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(int)row;
- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;
</code></pre></li>
<li><p>冒号追加到类名前（参数是对委托对象的引用），并且该方法只有一个参数，即发送者。</p>
<pre><code class="language-text">- (BOOL)applicationOpenUntitledFile:(NSApplication *)sender;
</code></pre></li>
<li><p>对此的一个例外是由于发布通知而调用的方法。在这种情况下，唯一的参数是通知对象。</p>
<pre><code class="language-text">- (void)windowDidChangeScreen:(NSNotification *)notification;
</code></pre></li>
<li><p>对于被调用以通知委托已发生或即将发生某些事情的方法，请使用“did”或“will”。</p>
<pre><code class="language-text">- (void)browserDidScroll:(NSBrowser *)sender;
- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window;
</code></pre></li>
<li><p>虽然您可以使用“did”或“will”来调用要求委托代表另一个对象执行某些操作的方法，但首选“should”。</p>
<pre><code class="language-text">- (BOOL)windowShouldClose:(id)sender;
</code></pre></li>
</ul>

<h3 id="toc_7">④集合方法</h3>

<p>对于管理对象集合的对象（每个对象称为该集合的元素），约定是具有以下形式的方法：</p>

<pre><code class="language-text">- (void)addElement:(elementType)anObj;

- (void)insertElement:(elementType)anObj atIndex:(int)index;

- (void)removeElement:(elementType)anObj atIndex:(int)index;

- (void)removeElement:(elementType)anObj;

- (NSArray *)elements;
</code></pre>

<p>有一点需要主要如果集合是真正无序的，那么返回NSSet而不是NSArray</p>

<h3 id="toc_8">⑤方法参数</h3>

<p>有一些关于方法参数名称的一般规则：</p>

<ul>
<li>与方法一样，参数以小写字母开头，连续单词的第一个字母大写（例如，removeObject:(id)anObject）。</li>
<li>不要在名称中使用“pointer”或“ptr”。使用参数的类型而不是它的名称声明它是否是指针。</li>
<li>避免使用单字母和双字母名称作为参数。</li>
<li>避免只保存几个字母的缩写。</li>
</ul>

<p>常用的方法参数</p>

<pre><code class="language-...action:(sel)aselector">...alignment:(int)mode
...atIndex:(int)index
...content:(NSRect)aRect
...doubleValue:(double)aDouble
...floatValue:(float)aFloat
...font:(NSFont *)fontObj
...frame:(NSRect)frameRect
...intValue:(int)anInt
...keyEquivalent:(NSString *)charCode
...length:(int)numBytes
...point:(NSPoint)aPoint
...stringValue:(NSString *)aString
...tag:(int)anInt
...target:(id)anObject
...title:(NSString *)aString
</code></pre>

<h3 id="toc_9">⑥私有方法</h3>

<p>在大多数情况下，私有方法名称通常遵循与公共方法名称相同的规则。但是，常见的约定是为私有方法提供前缀，以便很容易将它们与公共方法区分开来。即使采用这种约定，私有方法的名称也可能导致一种特殊类型的问题。当您设计Cocoa框架类的子类时，您无法知道您的私有方法是否无意中覆盖了具有相同名称的私有框架方法。</p>

<p>Cocoa框架中大多数私有方法的名称都有一个下划线前缀（例如_fooData），以将它们标记为私有。从这个事实可以看出两个建议。</p>

<ul>
<li>不要使用下划线字符作为私有方法的前缀。</li>
<li>如果您是一个大型Cocoa框架类（如NSView或UIView）的子类，并且您希望绝对确定您的私有方法的名称与超类中的名称不同，则可以将自己的前缀添加到私有方法中。前缀应尽可能唯一，可能基于您的公司或项目以及“XX_”形式。因此，如果您的项目名为Byte Flogger，则前缀可能是 BF_addObject:</li>
</ul>

<p>虽然给私有方法名称加一个前缀的建议似乎与先前声称方法存在于其类的命名空间中的说法相矛盾，但这里的意图是不同的：防止无意覆盖超类私有方法。</p>

<h2 id="toc_10">3️⃣命名函数</h2>

<p>Objective-C允许您通过函数和方法表达行为。当底层对象总是单例或者处理明显功能的子系统时，你应该使用函数而不是类方法。</p>

<p>函数有一些通用的命名规则，您应该遵循：</p>

<ul>
<li><p>函数名称与方法名称类似，但有几个例外：</p>
<ul>
<li>它们以您用于类和常量的相同前缀开头。</li>
<li>前缀后面的单词的第一个字母是大写的。</li>
</ul></li>
<li><p>大多数函数名称以描述函数具有的效果的动词开头：</p>
<pre><code class="language-text">NSHighlightRect
NSDeallocateObject
</code></pre></li>
</ul>

<p>查询属性的函数具有另一组命名规则：</p>

<ul>
<li><p>如果函数返回其第一个参数的属性，则省略动词。</p>
<pre><code class="language-text">unsigned int NSEventMaskFromType(NSEventType type)
float NSHeight(NSRect aRect)
</code></pre></li>
<li><p>如果通过引用返回值，请使用“get”。</p>
<pre><code class="language-text">const char *NSGetSizeAndAlignment(const char *typePtr, unsigned int *sizep, unsigned int *alignp)
</code></pre></li>
<li><p>如果返回的值是布尔值，则该函数应以变形动词开头。</p>
<pre><code class="language-text">BOOL NSDecimalIsNotANumber(const NSDecimal *decimal)
</code></pre></li>
</ul>

<h2 id="toc_11">4️⃣命名属性和数据类型</h2>

<h4 id="toc_12">①声明的属性和实例变量</h4>

<p>一个属性声明有效地声明了访问器的属性方法，如果属性表示为名词或动词，则格式为：<code>@property (…) type nounOrVerb;</code></p>

<pre><code class="language-text">@property (strong) NSString *title;
@property (assign) BOOL showsAlpha;
</code></pre>

<p>但是，如果声明的属性的名称表示为形容词，则属性名称将省略“is”前缀，但指定get访问器的常规名称，例如：</p>

<pre><code class="language-text">@property (assign, getter=isEditable) BOOL editable;
</code></pre>

<h4 id="toc_13">②常量</h4>

<p>常量的规则根据常量的创建方式而有所不同。</p>

<h5 id="toc_14">2.1 枚举常量</h5>

<ul>
<li>对具有整数值的相关常量组使用枚举。</li>
<li><p>枚举常量和它们分组的typedef遵循函数的命名约定。以下示例来自NSMatrix.h：</p>
<pre><code class="language-text">typedef enum _NSMatrixMode {
    NSRadioModeMatrix           = 0,<br/>
    NSHighlightModeMatrix       = 1,<br/>
    NSListModeMatrix            = 2,<br/>
    NSTrackModeMatrix           = 3<br/>
} NSMatrixMode;
</code></pre>
<p>⚠️注意，typedef标签是不必要的。</p></li>
<li><p>可以用位掩码等内容创建未命名的枚举，例如：</p>
<pre><code class="language-text">enum {
    NSBorderlessWindowMask      = 0,<br/>
    NSTitledWindowMask          = 1 &lt;&lt; 0,<br/>
    NSClosableWindowMask        = 1 &lt;&lt; 1,<br/>
    NSMiniaturizableWindowMask  = 1 &lt;&lt; 2,<br/>
    NSResizableWindowMask       = 1 &lt;&lt; 3<br/>
};
</code></pre></li>
</ul>

<h5 id="toc_15">2.2 用const创建的常量</h5>

<ul>
<li>const创建浮点值常量。如果常量与其他常量无关，则可以用来const创建整数常量; 否则，使用枚举。</li>
<li><p>const常量的格式由以下声明举例说明：</p>
<pre><code class="language-text">const float NSLightGray;
</code></pre></li>
</ul>

<h5 id="toc_16">2.3其他类型的常量</h5>

<ul>
<li>通常，不要使用#define预处理器命令来创建常量。对于整数常量，使用枚举，对于浮点常量，使用const限定符，如上所述。</li>
<li><p>对预处理器在确定是否将处理代码块时评估的符号使用大写字母。例如：<code>#ifdef DEBUG</code></p></li>
<li><p>请注意，编译器定义的宏具有前导和尾随双下划线字符。例如：<code>__MACH__</code></p></li>
<li><p>定义用于通知名称和字典键等用途的字符串的常量。通过使用字符串常量。如：<code>APPKIT_EXTERN NSString * NSPrintCopies;</code></p>
<pre><code class="language-text">#import &lt;UIKit/UIKitDefines.h&gt;
UIKIT_EXTERN  NSString * NSPrintCopies;
</code></pre></li>
</ul>

<h4 id="toc_17">③通知和异常</h4>

<p>通知和例外的名称遵循类似的规则。但两者都有自己推荐的使用模式。</p>

<ul>
<li>通知</li>
</ul>

<p>如果一个类有一个委托，那么它的大部分通知都可能由委托通过一个已定义的委托方法接收。这些通知的名称应反映相应的委托方法。例如，全局NSApplication对象的委托自动注册，以便applicationDidBecomeActive:在应用程序发布时接收消息NSApplicationDidBecomeActiveNotification。</p>

<pre><code class="language-text">通知由全局NSString对象标识，其名称以这种方式组成：
[关联类的名称] + [Did | will] + [UniquePartOfName] +通知
NSApplicationDidBecomeActiveNotification
NSWindowDidMiniaturizeNotification
NSTextViewDidChangeSelectionNotification
NSColorPanelColorDidChangeNotification

</code></pre>

<ul>
<li>异常</li>
</ul>

<p>用来处理抛出的NSException使用异常。</p>

<p>异常由全局NSString对象标识，其名称以这种方式组成：</p>

<p><code>[Prefix] + [UniquePartOfName] + Exception<br/>
</code>比如</p>

<pre><code class="language-text">NSColorListIOException
NSColorListNotEditableException
NSDraggingException
NSFontUnavailableException
NSIllegalSelectorException
</code></pre>

<h2 id="toc_18">5️⃣框架开发人员的技巧和技巧</h2>

<p>开发框架有他们如何编写自己的代码比其他开发商更加谨慎。许多客户端应用程序可以在其框架中链接，并且由于这种广泛的暴露，框架中的任何缺陷可能会在整个系统中被放大。以下各项讨论了可以采用的编程技术，以确保框架的效率和完整性。</p>

<ul>
<li>类初始化</li>
</ul>

<p>在调用类的任何其他方法之前，initialize  类方法为您提供了一个懒惰地执行一次代码的地方。</p>

<p>运行时发送initialize到继承链中的每个类，即使它没有实现它; 因此它可能initialize不止一次地调用一个类的方法（例如，如果一个子类没有实现它）。通常，您希望初始化代码只执行一次。确保这种情况发生的一种方法是使用dispatch_once()：</p>

<pre><code class="language-text">+ (void)initialize {
    static dispatch_once_t onceToken = 0;
    dispatch_once(&amp;onceToken, ^{
        // the initializing code
    }
}
</code></pre>

<p>⚠️注意：  因为运行时将initialize发送到每个类，所以可能initialize会在子类的上下文中调用 - 如果子类没有实现initialize，那么调用将落入超类。如果您特别需要在相关类的上下文中执行初始化，则可以执行以下检查而不是使用dispatch_once()：</p>

<pre><code class="language-text">if（self == [NSFoo class]）{
    //初始化代码
}
</code></pre>

<ul>
<li>指定的初始化器</li>
</ul>

<p>指定的初始值设定init项是调用init超类方法的类的方法。（其他初始值设定项调用init类定义的方法。）每个公共类都应该有一个或多个指定的初始值设定项。</p>

<p>当您实现一个框架类时，您通常还必须实现其归档方法：initWithCoder:和encodeWithCoder:。注意不要在初始化代码路径中执行在取消归档对象时不会发生的事情。实现这一目标的一个好方法是，initWithCoder:如果您的类实现了归档，则从您指定的初始化程序和（它本身是指定的初始化程序）调用一个公共例程。</p>

<ul>
<li><p>初始化期间的错误检测</p>
<ul>
<li>通过调用重新分配自我super的指定初始化。</li>
<li>检查返回值nil，这表示超类初始化中发生了一些错误。</li>
<li>如果在初始化当前类时发生错误，请释放该对象并返回nil。</li>
</ul></li>
</ul>

<p>下面是🌰代码</p>

<pre><code class="language-text">- (id)init {
    self = [super init];  // Call a designated initializer here.
    if (self != nil) {
        // Initialize object  ...
        if (someError) {
            [self release];
            self = nil;
        }
    }
    return self;
}
</code></pre>

<h4 id="toc_19">参考</h4>

<p>[1]<a href="https://dwz.cn/oY1q9z0N">Apple Guideline</a><br/>
[2]<a href="https://juejin.im/entry/5be2810e518825158c530d9b">iOS Coding Style Guide 代码规范</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/12/11</span>
                    
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509805631.html">
                
                  <h1>UINavigationItem</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>纵观Apple的官方应用程式的导航栏你就会发现在iOS11之后导航栏的高度会自动变化，文字的大小以及位置也会随之变化。<br/>
这是iOS11之后的新特性，苹果是使用给UINavigationItem添加扩展的方法增加的新功能，这也给了我们新的一种思路，为了不去修改之前代码的原则上添加新的功能的方式。</p>

<pre><code class="language-text">extension UINavigationItem {
    public enum LargeTitleDisplayMode : Int {
        /// Automatically use the large out-of-line title based on the state of the previous item in the navigation bar. An item with largeTitleDisplayMode=Automatic will show or hide the large title based on the request of the previous navigation item. If the first item pushed is set to Automatic, then it will show the large title if the navigation bar has prefersLargeTitles=YES.
        case automatic

        
        /// Always use a larger title when this item is top most.
        case always

        
        /// Never use a larger title when this item is top most.
        case never
    }
}
</code></pre>

<ul>
<li>largeTitie的两种展现形式如下所示</li>
</ul>

<p><img src="media/15439873228318/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%881.23.25.png" alt="屏幕快照 2018-12-05 下午1.23.25 " style="width:220px;"/><img src="media/15439873228318/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%881.23.29.png" alt="屏幕快照 2018-12-05 下午1.23.29 " style="width:220px;"/></p>

<h2 id="toc_0">设置方式</h2>

<ul>
<li><p>xib设置</p>
<ul>
<li>never 一直都是小标题</li>
<li>automatic 自动切换</li>
<li>always 一直都是大标题</li>
</ul></li>
</ul>

<p><img src="media/15439873228318/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-05%20%E4%B8%8B%E5%8D%881.30.58.png" alt="屏幕快照 2018-12-05 下午1.30.58"/></p>

<ul>
<li><p>代码设置</p>
<pre><code class="language-text">因为这是新增加的属性所以要做判断
 if #available(iOS 11.0, *) {<br/>
        self.navigationItem.largeTitleDisplayMode = .automatic<br/>
        } else {<br/>
            // Fallback on earlier versions<br/>
};
</code></pre></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/12/11</span>
                    
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509805667.html">
                
                  <h1>疑问</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>为什么不对比收到的离线消息和当前群聊的群聊id比对就直接去对当前群聊的消息进行处理</p>

<pre><code class="language-text">//WYMTCChatGroupViewController.m
- (void)handleOfflineGroupMessage:(NSNotification *)notification {
    NSDictionary * userInfoDic = notification.userInfo;
    if (userInfoDic) {
        [self fetchGroupMessageListWithOffset:0 pageSize:20];
    }
}

</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/12/11</span>
                    
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509805787.html">
                
                  <h1>Advanced Debugging with Xcode and LLDB</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ol>
<li><p>expression语句 </p>
<p>不用重新运行程序直接实现代码效果</p>
<p><img src="media/15444306104604/15445067738160.jpg" alt=""/></p>
<ol>
<li><p>描述</p>
<p>可以动态的改变条件，语法是<code>expression xxx = &quot;xxx&quot;</code> 后面是语句代码,类似程序中的代码并且支持加{}的判断等等语句。</p></li>
<li><p>使用方法：</p>
<ul>
<li>调试台去写这个语句</li>
<li>加断点去添加<code>action</code>。</li>
</ul></li>
</ol></li>
<li><p>Symbolic Breakpoint</p>
<ol>
<li><p>描述</p>
<p>符号断点，可以针对某一个方法(函数)设置断点并暂停执行；有时候，我们并不清楚会在什么情况下调用某一个函数，那我们可以通过符号断点来跟踪获取调用该函数的程序堆栈。</p>
<p><img src="media/15444306104604/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.04.43.png" alt="屏幕快照 2018-12-10 下午5.04.43"/></p></li>
<li><p>使用方法</p>
<ul>
<li> 方法一</li>
</ul>
<p>添加符号断点，比如如下所述-[UILabel setText:]</p>
<p><img src="media/15444306104604/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.05.33.png" alt="屏幕快照 2018-12-10 下午5.05.33"/></p>
<p>还可以添加condition语句 类似如上所述</p>
<ul>
<li>方法二</li>
</ul>
<p>直接在指定的语句添加断点加入<code>action</code>语句，如图所示</p>
<p><img src="media/15444306104604/15445068230815.jpg" alt=""/></p>
<p><code>breakpoint set --one-shot true --name &quot;-[UILabel setText:]&quot;</code>    </p>
<p><code>one-shot</code> 是一个临时断点，一旦触发后就自动删除</p></li>
</ol></li>
<li><p>跳过断点所指向的代码</p>
<ol>
<li><p>方式一</p>
<p><img src="media/15444306104604/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.40.21.png" alt="屏幕快照 2018-12-10 下午5.40.21"/></p>
<p>移动手柄实现 接下来就可以在控制台中写expression语句 <br/>
<code>expression jumpAstronaut(animated:false)<br/>
</code></p></li>
<li><p>方式二</p>
<p>直接编辑断点添加action语句 <br/>
<img src="media/15444306104604/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%20%E4%B8%8B%E5%8D%885.47.11.png" alt="屏幕快照 2018-12-10 下午5.47.11"/></p>
<p><code>thread jump --by 1</code> 是跳过一句代码的意思。</p></li>
</ol></li>
<li><p>watchPoint </p>
<p>观察指针，值发生改变的时候自动暂停。</p>
<p><img src="media/15444306104604/15445000921722.jpg" alt=""/></p>
<p>右键某个属性，添加watchPoint，然后左侧会出现观察指针断点监测_tableView的变化，如下所示<br/><br/>
    <img src="media/15444306104604/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8A%E5%8D%8811.46.38.png" alt="屏幕快照 2018-12-11 上午11.46.38"/></p></li>
<li><p>创建别名</p>
<p><code>command alias poc expression - l objc -O --</code><br/>
poc 就可以直接代替后面的语句，可以简化常用的命令行语句。</p></li>
<li><p>可以通过内存地址去获取对象 </p>
<ol>
<li><p>Objective-C</p>
<p><code>po 指针</code> 可以直接打印出对象<br/>
<img src="media/15444306104604/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8A%E5%8D%8811.12.11.png" alt="屏幕快照 2018-12-11 上午11.12.11"/></p></li>
<li><p>Swift</p>
<p>不能把数字当成指针去像OC一样打印出对象，要使用<code>expression - l objc -O -- 0x7fa967d781191548b60</code>转换为OC语言。 如果觉得这个语句太臃肿，可以为语句创建别名比如<code>command alias poc expression - l objc -O --</code>之后就可以直接<code>poc 指针</code>就可以达到oc当中同样的效果。</p></li>
</ol></li>
<li><p>获取图层树</p>
<ol>
<li><p>Objective-C</p>
<p>调用<code>po [self.view recursiveDescription]</code>打印出类似于这样的图层树。<br/>
<img src="media/15444306104604/15444967235409.jpg" alt=""/></p></li>
<li><p>Swift </p>
<p>不能这么直接打印出图层树（swift不允许去调用未定义的函数），如果要让swift去像OC一样打印出类似于这样的图层树。<br/>
调用语句</p>
<pre><code class="language-expression">```一定要加入反括号(反括号就像预处理器一样，它表示先评估其在当前帧中的内容，并插入结果，然后我们可以评估其余部分) 才能编译通过。
</code></pre></li>
</ol></li>
<li><p>unsafeBitCast查询对象的调试描述</p>
<p>当只有指针，查看对象描述的时候在swift中可以使用 unsafeBitCast函数，给他一个内存地址，他不安全是因为它依赖你来提供正确的类型。</p>
<p>po unsafeBitCast(指针,to:ScoreBoardView.self)<br/>
还可以可以直接查看view的frame<br/>
po unsafeBitCast(指针,to:ScoreBoardView.self).frame</p>
<p>同理OC中可以更方便的实现根据指针对对象进行相应的调试，比如更改 label 的内容</p>
<pre><code class="language-text">(lldb) expression [(UILabel*)0x7fb2c5f0fd70 setText:@&quot;hello&quot;];
但是内存地址前面要跟相应的类型要不然会执行失败报错<br/>
error: warning: receiver type &#39;long&#39; is not &#39;id&#39; or interface pointer, consider casting it to &#39;id&#39;
</code></pre></li>
<li><p>刷新屏幕的帧缓存区<br/>
如果写了expression语句之后界面没有及时刷新，但是又不想去重新运行代码，那么可以使用表达式<br/>
Swift<code>expression CATransaction.flush()</code><br/>
OC<code>expression [CATransaction flush]</code>刷新屏幕帧缓存区。</p></li>
</ol>

<h3 id="toc_0">参考</h3>

<p>[1]<a href="https://developer.apple.com/videos/play/wwdc2018/412/">https://developer.apple.com/videos/play/wwdc2018/412/</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/12/11</span>
                    
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509805828.html">
                
                  <h1>App Icon Design</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Design</h2>

<p>我们对符号的应用可以追溯到很久很久之前，总所周知我们现在使用的文字就是从象形文字发展过来的。</p>

<ul>
<li><p>象征化</p>
<p>找到一个简单易懂的象征，物体、图形标注或者符号。</p></li>
<li><p>简单性</p>
<p>设计要简单，不要杂乱无章，太过复杂。如果设计的好，人们一眼就能看懂。</p></li>
<li><p>关联性</p>
<p>创建与用户之间的感情连接，跟UI一样，图标是应用的脸面，一定要有趣并且引人注目</p></li>
<li><p>传统性</p>
<p>对图标的修改要有意义而且谨慎，不建议经常更改应用图标尤其是每次升级的时候，要与时俱进。</p></li>
</ul>

<p>比如最初的keynote的图标就是一张讲台，以后的每次迭代升级都是围绕着讲台进行的改变，是与时俱进的，风格不断变化。而且如果你注意到的话讲台上都有一个话筒，这个也是一直有延续的。</p>

<p><img src="media/15445081328797/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%882.16.00.png" alt="屏幕快照 2018-12-11 下午2.16.00"/></p>

<p>iOS平台与macOS设计的不同又相同。</p>

<p><img src="media/15445081328797/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%882.19.41.png" alt="屏幕快照 2018-12-11 下午2.19.41"/></p>

<p>配色，元素都是类似的，而且iOS的iwork图标更是保持了一致性，一致的地平面，一致的白色，没有多余复杂的元素。</p>

<p>现在来看GarageBand和Music Memos的关系，有颜色和图标来看，明显有关系。圆圈代表了木吉他上的音孔，弦的振动很清晰很有趣，让人感到动感和创造力</p>

<p><img src="media/15445081328797/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%882.24.00.png" alt="屏幕快照 2018-12-11 下午2.24.00"/></p>

<h5 id="toc_1">Q:怎么不显示名字，也能让人理解。</h5>

<p>A:高对比度，颜色清晰可见，设计简单，构图独特。</p>

<p>下面是News的图标的例子。</p>

<p><img src="media/15445081328797/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%882.32.55.png" alt="屏幕快照 2018-12-11 下午2.32.55"/></p>

<p>进行了三次改变设计，才做到简单醒目，即使在文件夹的小图标也会一目了然，这点对于App Icon Design 十分重要。</p>

<p><img src="media/15445081328797/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%882.34.30.png" alt="屏幕快照 2018-12-11 下午2.34.30"/></p>

<h2 id="toc_2">Process</h2>

<p>设计是一个交互过程，设计时要去考虑这些环节。</p>

<ul>
<li><p>独特性 </p>
<p>要做到有区分性，特别是对于一些类似功能的APP</p>
<p><img src="media/15445081328797/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%882.41.11.png" alt="屏幕快照 2018-12-11 下午2.41.11"/></p></li>
<li><p>实践</p>
<p>纸笔有时候比鼠标有用的多，绘画是激发灵感的好方法。</p>
<p><img src="media/15445081328797/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%882.40.50.png" alt="屏幕快照 2018-12-11 下午2.40.50"/></p></li>
<li><p>测试</p>
<p>要在主屏，在设置，在文件夹中测试不同情形的展示效果，要用图标展现界面的话要特别注意，Clear是一个很完美的典范，简单，多彩，高对比度。</p>
<p><img src="media/15445081328797/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%882.41.54.png" alt="屏幕快照 2018-12-11 下午2.41.54"/></p></li>
<li><p>耐心</p>
<p>答案不会立马就来，慢慢来，检查选项，保存好作品，有时候最简单的设计或者你放弃的设计师最好的选择。</p></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/12/11</span>
                    
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509805868.html">
                
                  <h1>Love at First Launch</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>直接显示内容而不是弹出需要注册登录的页面</li>
<li>通过交互引导用户，而不是一些文字引导</li>
<li>延迟请求授权，而不是一下登录之后就开始要权限（定位，相机，图片）。</li>
</ul>

<p>针对延迟请求，想到一个好主意，就是新建一个类，可以是单例，负责管理这些请求。</p>

<h1 id="toc_0">App Startup Time: Past, Present, and Future</h1>

<p>了解在苹果平台上使用的dyld动态链接器，它是如何在这些年来发生变化的，以及它下一步的发展方向。了解改进的工具如何使优化应用程序的启动时间变得更容易，并了解dyld中的新更改如何进一步改善启动时间。</p>

<ul>
<li><p>startup time 启动时间</p>
<p>main函数执行之前所用的时间</p></li>
<li><p>launch closure启动收尾</p>
<p>启动你的程序所需要的全部信息，比如使用什么dylib，他们的哪些偏移位置用于不同的符号，代码签名是什么，</p></li>
</ul>

<h2 id="toc_1">Improving App Startup Time</h2>

<p>Do less！</p>

<ul>
<li>Ember fewer dylibs</li>
<li>Declear fewer classes/methods</li>
<li>Use fewer initializers</li>
</ul>

<p>减少代码，代码越少，启动速度越快。使用更少的dylib，减少嵌入的dylib,使用系统库效果会更好。应该声明较少的库和方法，减少初始化函数( <u>初始化函数是在main函数执行之前执行</u> )。</p>

<p>Use more Swift</p>

<ul>
<li>No initializers</li>
<li>Swift size improvements</li>
</ul>

<p>因为Swift从设计上避免了许多的陷阱，在c、c+++、oc可能遇到这些陷阱。<br/>
Swift没有初始化器，不允许特定类型的未对齐的数据结构。所以转向Swift可以让你更容易获得快速的程序启动(Apple says)。</p>

<h2 id="toc_2">Static initilizer tracing</h2>

<p>静态初始化追踪器，instrument提供每个静态初始化器的准确时间。方便知道初始化的过程花费了多久的时间。</p>

<p><img src="media/15445109745059/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%883.33.52.png" alt="屏幕快照 2018-12-11 下午3.33.52"/></p>

<h2 id="toc_3">dyld3</h2>

<h4 id="toc_4">为什么推出dylb3</h4>

<p>提升速度（启动应用的时候尽量多的减少工程量）<br/>
增强安全（更积极的安全检查）<br/>
可测试性和可靠性</p>

<h4 id="toc_5">怎么做到上述目标</h4>

<ul>
<li><p>速度</p>
<ul>
<li><p>把复杂操作dylb移出进程</p>
<ul>
<li>现在大多数dylb只是普通的后台程序</li>
</ul></li>
<li><p>允许部分dylb驻留在进程之中</p>
<ul>
<li>减少受攻击面积（驻留部分要尽可能少）</li>
<li>提高启动速度
<ul>
<li>最快的代码就是你不写代码</li>
<li>关注那些你几乎不执行的代码</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>安全</p>
<ul>
<li><p>确定安全敏感性组件身份</p>
<ul>
<li>边界检查</li>
<li>@rpath 攻击</li>
</ul></li>
<li><p>标识可占用缓存的组件</p>
<ul>
<li>依赖关系不会改变</li>
<li>符号在库中的偏移位置不会发生改变 </li>
</ul></li>
</ul></li>
</ul>

<p><img src="media/15445109745059/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-11%20%E4%B8%8B%E5%8D%885.36.31.png" alt="屏幕快照 2018-12-11 下午5.36.31"/></p>

<p>dylb3有三个部分</p>

<ul>
<li>一个进程外的macho 解析编译器</li>
<li>一个进程内的处理闭包（launch closures）的引擎</li>
<li>一个缓存服务的启动闭包（launch closures）</li>
</ul>

<p>大多数启动的时候使用缓存不会触发进程外的mach-o parser/compiler<br/>
launch closures比mach-o更简单<br/>
launch closures为速度而构建</p>

<h3 id="toc_6">使用dylb3要注意什么</h3>

<p>完全兼容dylb2.x</p>

<ul>
<li>一些apis关闭了dylb3的优化导致程序变慢或者会在dylb3中使用回退模式</li>
<li>一些为dylb2.x的优化不再有任何影响</li>
</ul>

<p>严格的链接语义<br/>
在加入新动态连接器后，很多的语义可能现在还无法使用，甚至是错误的。</p>

<ul>
<li>放入一个支持旧二进制数据的工作区</li>
<li>新的二进制数据可能导致链接错误 </li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/12/11</span>
                    
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_4.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_6.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="%E7%94%B5%E5%BD%B1.html"><strong>电影</strong></a>
        
            <a href="%E5%85%B6%E5%AE%83.html"><strong>其它</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16076509803956.html">Xcode10报错libstdc</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16076509804011.html">Masonry布局“Unable to simultaneously satisfy constraints”</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16076509804045.html">RACCommand</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16076509804076.html">代理修饰符</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16076509804110.html">You don’t have write permissions</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
