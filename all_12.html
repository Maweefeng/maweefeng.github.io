<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
  
  
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="%E7%94%B5%E5%BD%B1.html">电影</a></li>
        
            <li><a href="%E5%85%B6%E5%AE%83.html">其它</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="iOS.html">iOS</a></li>
        
            <li><a href="%E6%88%91.html">我</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="16076509808799.html">
                
                  <h1>python3 urllib 访问https网站</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>ssl._create_default_https_context=ssl._create_unverified_context<br/>
urllib  urllib2 urllib3并不是进化关系<br/>
urllib和urllib2是相互独立的模版</p>

<h2 id="toc_0">列表</h2>

<ul>
<li>列表添加新元素<br/>
append()</li>
<li><p>列表删除元素</p>
<blockquote>
<p>pop()方法总是删掉list的最后一个元素，并且它还返回这个元素</p>
</blockquote>
<p>pop()</p>
<p>pop(2)删掉list中索引为2的元素</p></li>
</ul>

<h2 id="toc_1">元组</h2>

<p>元组和列表不同的是创建方式用()替代了[]，而且元组一旦创建就不能改变。</p>

<p>同样可以根据索引取到元组的内容。</p>

<pre><code class="language-text">&gt;&gt;&gt; t = (1)
&gt;&gt;&gt; print t
1
</code></pre>

<p>创建单元组需要注意，因为创建元组的方式是（）和运算优先级冲突了，所以上面的结果是1。</p>

<p>所以创建单元组要在第一个元素后自动添加一个&#39;,&#39;，就像下面的一样。</p>

<pre><code class="language-text">&gt;&gt;&gt; t = (1,)
&gt;&gt;&gt; print t
(1,)
</code></pre>

<p>还有需要注意的是元组也可以&#39;可变‘，其实这种可变并不是真正的可变。比如下面的这个例子，元组中包括一个数组，数组就可以改变。</p>

<pre><code class="language-text">&gt;&gt;&gt; t = (&#39;a&#39;, &#39;b&#39;, [&#39;A&#39;, &#39;B&#39;])
&gt;&gt;&gt; L = t[2]
&gt;&gt;&gt; L[0] = &#39;X&#39;
&gt;&gt;&gt; L[1] = &#39;Y&#39;
&gt;&gt;&gt; print t
(&#39;a&#39;, &#39;b&#39;, [&#39;X&#39;, &#39;Y&#39;])
</code></pre>

<h2 id="toc_2">set</h2>

<p>Python中什么是set<br/>
dict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。</p>

<p>有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。</p>

<p>set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。</p>

<p>创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素：</p>

<pre><code class="language-text">&gt;&gt;&gt; s = set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])
&gt;&gt;&gt; print s
set([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;])
</code></pre>

<h3 id="toc_3">Python之 访问set</h3>

<p>由于set存储的是无序集合，所以我们没法通过索引来访问。</p>

<p>访问 set中的某个元素实际上就是判断一个元素是否在set中。</p>

<p>例如，存储了班里同学名字的set：</p>

<p><code>&gt;&gt;&gt; s = set([&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;])<br/>
</code><br/>
我们可以用 in 操作符判断：</p>

<p>Bart是该班的同学吗？</p>

<pre><code class="language-text">&gt;&gt;&gt; &#39;Bart&#39; in s
True

</code></pre>

<h3 id="toc_4">Python之 遍历set</h3>

<p>由于 set 也是一个集合，所以，遍历 set 和遍历 list 类似，都可以通过 for 循环实现。</p>

<p>直接使用 for 循环可以遍历 set 的元素：</p>

<pre><code class="language-text">&gt;&gt;&gt; s = set([&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;])
&gt;&gt;&gt; for name in s:
...     print name
... 
Lisa
Adam
Bart
</code></pre>

<h3 id="toc_5">Python之 更新set</h3>

<p>add()添加<br/>
remove()删除</p>

<h3 id="toc_6">Python之 unicode编码</h3>

<pre><code class="language-text">在字符串前面加上u 比如
&gt;&gt;&gt;a = u&quot;123&quot;
&gt;&gt;&gt;type(a)
&gt;&gt;&gt;unicode

&gt;&gt;&gt;b = &quot;123&quot;
&gt;&gt;&gt;type(b)
&gt;&gt;&gt;str
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/12/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python.html'>Python</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509808836.html">
                
                  <h1>Scrapy 抓取网页数据</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Scrapy 介绍</h2>

<p>Scrapy，Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。<br/>
Scrapy吸引人的地方在于它是一个框架，任何人都可以根据需求方便的修改。它也提供了多种类型爬虫的基类，如BaseSpider、sitemap爬虫等，最新版本又提供了web2.0爬虫的支持。<br/>
Scrap，是碎片的意思，这个Python的爬虫框架叫Scrapy。</p>

<p>首先必须有python的环境，如果没有的话需要安装，目前python2.x已经不再更新，我使用的是python3的环境。</p>

<p>如果你已经有了python3的环境并且已经安装了pip3，那么安装scrapy只需要一行命令即可。</p>

<pre><code class="language-text">pip3 install scrapy
</code></pre>

<p>如果你还没有安装pip3的话，建议先安装pip3进行包管理。</p>

<h2 id="toc_1">pip3</h2>

<p>pip 是 Python 包管理工具，该工具提供了对Python 包的查找、下载、安装、卸载的功能。<br/>
Python 2.7.9 + 或 Python 3.4+ 以上版本都自带 pip 工具。<br/>
你可以通过以下命令来判断是否已安装：</p>

<pre><code class="language-text">pip --version
</code></pre>

<p>如果你还未安装，则可以使用以下方法来安装：</p>

<pre><code class="language-text">$ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py   # 下载安装脚本
$ sudo python get-pip.py    # 运行安装脚本
</code></pre>

<p>注意：用哪个版本的 Python 运行安装脚本，pip 就被关联到哪个版本，如果是 Python3 则执行以下命令：</p>

<pre><code class="language-text">$ sudo python3 get-pip.py    # 运行安装脚本。
</code></pre>

<p>一般情况 pip 对应的是 Python 2.7，pip3 对应的是 Python 3.x。</p>

<pre><code class="language-text">&gt;&gt;&gt;pip3  -h#查看pip3的命令
Commands:
  install                     Install packages.
  download                    Download packages.
  uninstall                   Uninstall packages.
  freeze                      Output installed packages in requirements format.
  list                        List installed packages.
  show                        Show information about installed packages.
  check                       Verify installed packages have compatible dependencies.
  config                      Manage local and global configuration.
  search                      Search PyPI for packages.
  wheel                       Build wheels from your requirements.
  hash                        Compute hashes of package archives.
  completion                  A helper command used for command completion.
  help                        Show help for commands.
</code></pre>

<p>比较常用的就是install，list，一个是安装某个框架，另一个是列出所有安装的python框架。</p>

<h2 id="toc_2">demo 抓取豆瓣前250名的电影</h2>

<h3 id="toc_3">新建scrapy项目</h3>

<ol>
<li>scrapy startproject 项目名称</li>
<li>cd 进入到项目名称 </li>
<li>cd 进入到 spiders</li>
<li>scrapy genspider xxx_spider 域名 #生成爬虫类
<ul>
<li>比如scrapy genspider douban_spider movie.douban.com</li>
</ul></li>
</ol>

<p>项目目录如下</p>

<ul>
<li>douban
<ul>
<li>spiders
<ul>
<li>douban_spider.py #最重要的爬虫类</li>
</ul></li>
<li>items.py #爬取的model类</li>
<li>middlewares.py #中间件 伪装useragent或者设置代理</li>
<li>pipelines.py #管道类 数据同步 </li>
<li>settings.py #设置类 里面有一些项目的配置</li>
</ul></li>
</ul>

<h3 id="toc_4">运行项目</h3>

<p>有两种方法</p>

<ol>
<li>打开命令行工具 <code>scrapy crawl xxx_spider</code></li>
<li><p>建议使用scrapy的cmdline工具</p>
<ul>
<li><p>在spiders文件夹下新建入口main.py </p>
<pre><code class="language-text">from scrapy import cmdline
cmdline.execute(&#39;scrapy crawl baidubaike_spider&#39;.split())
</code></pre>
<p>每次从这里面运行.py就行了,不需要每次都进到特定目录运行termianl终端程序。</p></li>
</ul></li>
</ol>

<h3 id="toc_5">主要爬虫类</h3>

<p>douban_spider.py </p>

<pre><code class="language-text"># -*- coding: utf-8 -*-
import scrapy

class DoubanSpiderSpider(scrapy.Spider):
    name = &#39;douban_spider&#39;#爬虫名
    allowed_domains = [&#39;movie.douban.com&#39;]
    start_urls = [&#39;https://movie.douban.com/top250&#39;]#入口url 扔到调度器里面
    #默认的解析方法
    def parse(self, response):
    #response就是网络请求之后的响应数据
    #主要的代码解析都在这个类中进行
       pass

</code></pre>

<h3 id="toc_6">HTML解析器</h3>

<p>爬取之后的数据如果为html就需要用到html解析器，业界一般有三种方式进行解析</p>

<ul>
<li>Beautiifulsoup</li>
<li>正则匹配式</li>
<li>lxml中的xpath </li>
</ul>

<p>有人做过三个方法的比较，大致结果如下</p>

<table>
<thead>
<tr>
<th></th>
<th>lxml</th>
<th>beautifulsoup</th>
<th>re</th>
</tr>
</thead>

<tbody>
<tr>
<td>语法难易度</td>
<td>简单</td>
<td>简单</td>
<td>复杂</td>
</tr>
<tr>
<td>查找速度</td>
<td>较快</td>
<td>慢</td>
<td>最快</td>
</tr>
</tbody>
</table>

<p>所以这里我使用的是lxml的方式进行html解析，也推荐新手从这个方式开始入门。</p>

<h4 id="toc_7">lxml</h4>

<p>lxml是通过xpath来查找，使用前需使用调用ertee.HTML()方法(&#39;()&#39;内填HTML代码)生成一个可查找的对象。</p>

<h5 id="toc_8">常用xpath语法如下</h5>

<pre><code class="language-text">// 两个斜杠为向下查找孙子标签
    
/ 一个斜杠为查找直接儿子标签
    
[] 方括号内填标签属性,如查找class属性为name的a标签,格式为a[@class=&quot;name&quot;]
    
/text() 取出标签的内容,如查找网页中的 &lt;a class=&quot;name&quot;&gt;KAINHUCK&lt;/a&gt; 中的KAINHUCK,格式为//a[@class=&quot;name&quot;]/text()
    
/@attr 取出标签的属性,如查找网页中的 &lt;a class=&quot;name&quot;&gt;KAINHUCK&lt;/a&gt; 中的class属性值name,格式为//a[@class=&quot;name&quot;]/@class 

</code></pre>

<h5 id="toc_9">xpath 如何提取出div下面所有标签的文本内容</h5>

<p>有时候一个div标签下会有不同的标签，如果只是单纯的使用上面的方法，并不能提取到div下面的所有文本内容，所以xpath提供了string(.)方法。</p>

<pre><code class="language-text">title = html.xpath(&#39;//dd[@class=&quot;lemmaWgt-lemmaTitle-title&quot;]/h1/text()&#39;)[0]

summary = html.xpath(&#39;//div[@class=&quot;lemma-summary&quot;]&#39;)[0].xpath(&#39;string(.)&#39;).strip()

#strip方法返回移除字符串头尾指定的字符生成的新字符串。    
</code></pre>

<h4 id="toc_10">分析抓取网站的html标签</h4>

<p>进入chrome打开开发者调试工具</p>

<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g3kate3mbuj30w00h3n21.jpg" alt=""/></p>

<p>另外要使用lxml的方式进行解析，可以安装插件进行查找，到chrome的商城下载xpath，这样就可以直接看到结果了，以防抓取到的标签出错。</p>

<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g3kavur7ggj30vt0h0q8t.jpg" alt=""/></p>

<pre><code class="language-text">//div[@class=&quot;article&quot;]//ol[@class=&quot;grid_view&quot;]/li
</code></pre>

<p>这段语法用于找到class为article的div标签下的class为grid_view的ol的子孙标签下的li标签。</p>

<p>查找出来的结果是个包含25个元素的list</p>

<h3 id="toc_11">代码编写</h3>

<p>然后进入到我们的代码中，导入lxml工具，以及DoubanItem</p>

<pre><code class="language-text"># -*- coding: utf-8 -*-
import scrapy
from lxml import etree
from douban.items import DoubanItem


class DoubanSpiderSpider(scrapy.Spider):
    name = &#39;douban_spider&#39;#爬虫名
    allowed_domains = [&#39;movie.douban.com&#39;]
    start_urls = [&#39;https://movie.douban.com/top250&#39;]#入口url 扔到调度器里面
    #默认的解析方法
    def parse(self, response):
        #循环电影的条目
        html = etree.HTML(response.text)
        movie_list = html.xpath(&#39;//div[@class=&quot;article&quot;]//ol[@class=&quot;grid_view&quot;]/li&#39;)
        for item in movie_list:
            #item文件导入
            douban_item = DoubanItem()
            #写详细的xpath 进行数据的解析
            douban_item[&#39;serial_number&#39;] = item.xpath(&#39;.//div[@class=&quot;item&quot;]//em/text()&#39;)[0]
            douban_item[&#39;movie_name&#39;] = item.xpath(&#39;.//div[@class=&quot;info&quot;]//a/span[1]/text()&#39;)[0]
            content_list = item.xpath(&#39;.//div[@class=&quot;info&quot;]//div[@class=&quot;bd&quot;]/p[1]/text()&#39;)
            for content in content_list:
                content_s = &quot;&quot;.join(content.split())
                douban_item[&#39;introduce&#39;] = content_s

            douban_item[&#39;star&#39;]= item.xpath(&#39;.//div[@class=&quot;star&quot;]/span[@class=&quot;rating_num&quot;]/text()&#39;)[0]
            douban_item[&#39;comment&#39;] = item.xpath(&#39;.//div[@class=&quot;star&quot;]/span[4]/text()&#39;)[0]
            douban_item[&#39;description&#39;] = item.xpath(&#39;.//p[@class=&quot;quote&quot;]/span[1]/text()&#39;)[0]
            print(douban_item)
            yield douban_item #yeild到piplines里面 进行数据清洗 数据存储
        
        #解析下一页规则 获取后一页的xpath
        next_link = html.xpath(&#39;//span[@class=&quot;next&quot;]/link/@href&#39;)

        if next_link:
            next_link = next_link[0]
            #yeild到调度器当中 后面给了回调函数
            yield scrapy.Request(&#39;https://movie.douban.com/top250&#39;+next_link,callback=self.parse)

</code></pre>

<p>其中重要的有yield方法，把我们生成的model类传输到piplines里面进行数据的存储。</p>

<p>还有就是因为这只是一页的数据，想要抓取的250条数据，那就要进行多次抓取，进过分析发现只需要每次把后页的a标签的href拿到就可以了，通过xpath进行解析就是 </p>

<pre><code class="language-text">#解析下一页规则 获取后一页的xpath
        next_link = html.xpath(&#39;//span[@class=&quot;next&quot;]/link/@href&#39;)

</code></pre>

<p>最好需要yeild到调度器当中，因为是部分路径，所以要先进行路径的拼接，还要指定回调函数，就是请求之后进入的回调方法。</p>

<h3 id="toc_12">数据导出</h3>

<p>在spiders文件夹下新建outputdata.py </p>

<pre><code class="language-text">#数据导出 也可以使用terminal 直接运行
from scrapy import cmdline
#数据导出到json
# cmdline.execute(&#39;scrapy crawl douban_spider -o output.json&#39;.split())

#数据导出到csv格式
cmdline.execute(&#39;scrapy crawl douban_spider -o output.csv&#39;.split())
</code></pre>

<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g3kbfcz850j30os0jf0y5.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/12/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python.html'>Python</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509808874.html">
                
                  <h1>xpath 提取div标签所有文字信息</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><img src="media/15591149863353/15591150079270.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/12/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python.html'>Python</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509808917.html">
                
                  <h1></h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h1 id="toc_0">curl</h1>

<p>抓取网页内容<br/>
curl -v <a href="https://www.imooc.com/video/13082">https://www.imooc.com/video/13082</a></p>

<p>把网页内容存储到tmp.txt<br/>
curl -v <a href="https://www.imooc.com/video/13082">https://www.imooc.com/video/13082</a> &gt; tmp.txt</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/12/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python.html'>Python</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509809222.html">
                
                  <h1>记录swift 当中超出以前认知的知识点</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">支持unicode编码的变量值</h2>

<pre><code class="language-text">let a = [Int]()
let 🐶🐮 = &quot;dogcow&quot;
let 你好 = &quot;你好世界&quot;
</code></pre>

<h2 id="toc_1">错误处理</h2>

<p>您使用错误处理来响应程序在执行期间可能遇到的错误情况。</p>

<p>与可以使用值的存在或不存在来传递函数成功或失败的选项相比，错误处理允许您确定失败的根本原因，并在必要时将错误传播到程序的另一部分。</p>

<p>当函数遇到错误条件时，它会抛出错误。然后该函数的调用者可以捕获错误并做出适当的响应。</p>

<pre><code class="language-text">func canThrowAnError() throws {
    // this function may or may not throw an error
}
</code></pre>

<p>函数表示它可以通过throws在其声明中包含关键字来引发错误。当您调用可以抛出错误的函数时，您可以将try关键字添加到表达式中。</p>

<p>Swift会自动将错误传播出当前作用域，直到它们被catch子句处理。</p>

<pre><code class="language-text">do {
    try canThrowAnError()
    // no error was thrown
} catch {
    // an error was thrown
}
</code></pre>

<p>一个do语句创建一个新的包含范围，允许误差传播到一个或多个catch条款。</p>

<p>以下是如何使用错误处理来响应不同错误条件的示例：</p>

<pre><code class="language-text">func makeASandwich() throws {
    // ...
}

do {
    try makeASandwich()
    eatASandwich()
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)
}
</code></pre>

<p>在此示例中，makeASandwich()如果没有可用的干净菜肴或缺少任何成分，该函数将抛出错误。因为makeASandwich()可以抛出错误，函数调用包含在try表达式中。通过将函数调用包装在do语句中，抛出的任何错误都将传播到提供的catch子句。</p>

<p>如果没有抛出错误，eatASandwich()则调用该函数。如果抛出错误并且它与SandwichError.outOfCleanDishes大小写匹配，则将washDishes()调用该函数。如果抛出错误并且它与SandwichError.missingIngredients大小写匹配，则buyGroceries(_:)调用该函数，并使用模式[String]捕获的关联值catch。</p>

<p>错误处理中更详细地介绍了抛出，捕获和传播错误。</p>

<h2 id="toc_2">一元减号算子</h2>

<p>可以使用前缀-（称为一元减号运算符）来切换数值的符号：</p>

<pre><code class="language-text">let three = 3
let minusThree = -three       // minusThree equals -3
let plusThree = -minusThree   // plusThree equals 3, or &quot;minus minus three&quot;
</code></pre>

<p>一元减号运算符（-）直接位于它运行的值之前，没有任何空格。</p>

<h2 id="toc_3">一元加运算符</h2>

<p>在一元加运算（+）只返回其所操作的价值，没有任何变化：</p>

<pre><code class="language-text">let minusSix = -6
let alsoMinusSix = +minusSix  // alsoMinusSix equals -6
</code></pre>

<p>虽然一元加运算符实际上没有做任何事情，但是当使用一元减运算符作为负数时，您可以使用它来为代码提供正数的对称性。</p>

<h2 id="toc_4">闭区域操作员</h2>

<p>的封闭范围操作符（a...b）限定了从运行范围a来b，并且包括这些值a和b。值a不得大于b。</p>

<p>当在您希望使用所有值的范围内进行迭代时，闭环范围运算符非常有用，例如使用for- in循环：</p>

<pre><code class="language-text">for index in 1...5 {
    print(&quot;\(index) times 5 is \(index * 5)&quot;)
}
// 1 times 5 is 5
// 2 times 5 is 10
// 3 times 5 is 15
// 4 times 5 is 20
// 5 times 5 is 25
</code></pre>

<p>有关for- in循环的更多信息，请参阅控制流。</p>

<h2 id="toc_5">半开放式操作员</h2>

<p>所述半开区间运算符（a..&lt;b）限定了从运行范围a到b，但不包括b。它被认为是半开放的，因为它包含它的第一个值，但不是它的最终值。与闭区域运算符一样，值a不得大于b。如果值a等于b，则结果范围将为空。</p>

<p>当您使用基于零的列表（如数组）时，半开范围特别有用，其中计算列表的长度（但不包括）非常有用：</p>

<pre><code class="language-text">let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]
let count = names.count
for i in 0..&lt;count {
    print(&quot;Person \(i + 1) is called \(names[i])&quot;)
}
// Person 1 is called Anna
// Person 2 is called Alex
// Person 3 is called Brian
// Person 4 is called Jack
</code></pre>

<p>请注意，该数组包含四个项目，但0..&lt;count只计算3（数组中最后一项的索引），因为它是半开放范围。有关数组的更多信息，请参阅数组。</p>

<h2 id="toc_6">单面范围</h2>

<p>闭区域运算符有一个替代形式，用于在一个方向上尽可能继续的范围 - 例如，包括从索引2到数组末尾的数组的所有元素的范围。在这些情况下，您可以省略范围运算符一侧的值。这种范围称为单侧范围，因为操作员仅在一侧具有值。例如：</p>

<pre><code class="language-text">for name in names[2...] {
    print(name)
}
// Brian
// Jack

for name in names[...2] {
    print(name)
}
// Anna
// Alex
// Brian
</code></pre>

<p>半开放范围操作符也具有单侧形式，仅使用其最终值编写。就像在两侧都包含值一样，最终值不是范围的一部分。例如：</p>

<pre><code class="language-text">for name in names[..&lt;2] {
    print(name)
}
// Anna
// Alex
</code></pre>

<p>单边范围可以在其他上下文中使用，而不仅仅在下标中使用。您不能迭代忽略第一个值的单侧范围，因为不清楚迭代应该从哪里开始。您可以迭代忽略其最终值的单侧范围; 但是，因为范围无限期地继续，请确保为循环添加显式结束条件。您还可以检查单侧范围是否包含特定值，如下面的代码所示。</p>

<pre><code class="language-text">let range = ...5
range.contains(7)   // false
range.contains(4)   // true
range.contains(-1)  // true
</code></pre>

<h3 id="toc_7">数组元素下标和值的对应关系</h3>

<p>如果需要每个项的整数索引及其值，请使用该enumerated()方法迭代数组。对于数组中的每个项，该enumerated()方法返回由整数和项组成的<code>元组</code>。整数从零开始，每个项目加1; 如果枚举整个数组，则这些整数与项目的索引相匹配。您可以将元组分解为临时常量或变量，作为迭代的一部分：</p>

<pre><code class="language-text">for (index, value) in shoppingList.enumerated() {
    print(&quot;Item \(index + 1): \(value)&quot;)
}
</code></pre>

<h2 id="toc_8">布尔值类型不能比较大小，元祖也是可以比较大小的。</h2>

<h2 id="toc_9">创建和初始化空集</h2>

<p>您可以使用初始化程序语法创建某个类型的空集：</p>

<pre><code class="language-text">var letters = Set&lt;Character&gt;()
</code></pre>

<p>Swift集的类型写为Set<Element>，Element允许集存储的类型在哪里。与数组不同，集合没有等效的简写形式</p>

<h2 id="toc_10">Set是一个无序的不重复元素的集合</h2>

<p>Swift的Set类型没有定义的顺序。要以特定顺序迭代集合的值，请使用该sorted()方法，该方法将集合的元素作为使用&lt;运算符排序的数组返回。</p>

<pre><code class="language-text">for genre in favoriteGenres.sorted() {
    print(&quot;\(genre)&quot;)
}
// Classical
// Hip hop
// Jazz
</code></pre>

<h2 id="toc_11">使用Array Literal创建集合</h2>

<p>您还可以使用数组文字初始化集合，作为将一个或多个值写为集合集合的简写方式。</p>

<p>下面的示例创建一个名为favoriteGenres存储String值的集合：</p>

<pre><code class="language-text">var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
// favoriteGenres has been initialized with three initial items
</code></pre>

<h2 id="toc_12">Set基本集合运算</h2>

<p><img src="https://docs.swift.org/swift-book/_images/setVennDiagram_2x.png" alt=""/></p>

<ul>
<li>使用该intersection(_:)方法创建一个仅包含两个集合共有值的新集合。</li>
<li>使用该symmetricDifference(_:)方法创建一个新集合，其中包含任一集合中的值，但不能同时创建两者。</li>
<li>使用该union(_:)方法创建包含两个集中所有值的新集。</li>
<li>使用此subtracting(_:)方法创建一个值不在指定集中的新集。</li>
</ul>

<pre><code class="language-text">let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]

oddDigits.union(evenDigits).sorted()
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
oddDigits.intersection(evenDigits).sorted()
// []
oddDigits.subtracting(singleDigitPrimeNumbers).sorted()
// [1, 9]
oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()
// [1, 2, 9]
</code></pre>

<ul>
<li>使用“is equal”运算符（==）来确定两个集合是否包含所有相同的值。</li>
<li>使用此isSubset(of:)方法确定集合的所有值是否都包含在指定的集合中。</li>
<li>使用此isSuperset(of:)方法确定集合是否包含指定集合中的所有值。</li>
<li>使用isStrictSubset(of:)或isStrictSuperset(of:)方法确定集合是否是指定集合的​​子集或超集，但不等于。</li>
<li>使用该isDisjoint(with:)方法确定两个集合是否没有共同的值。</li>
</ul>

<pre><code class="language-text">let houseAnimals: Set = [&quot;🐶&quot;, &quot;🐱&quot;]
let farmAnimals: Set = [&quot;🐮&quot;, &quot;🐔&quot;, &quot;🐑&quot;, &quot;🐶&quot;, &quot;🐱&quot;]
let cityAnimals: Set = [&quot;🐦&quot;, &quot;🐭&quot;]

houseAnimals.isSubset(of: farmAnimals)
// true
farmAnimals.isSuperset(of: houseAnimals)
// true
farmAnimals.isDisjoint(with: cityAnimals)
// true
</code></pre>

<h2 id="toc_13">创建一个空字典</h2>

<p>与数组一样，您可以Dictionary使用初始化程序语法创建某个类型的空：</p>

<pre><code class="language-text">var namesOfIntegers = [Int: String]()
// namesOfIntegers is an empty [Int: String] dictionary
</code></pre>

<h2 id="toc_14">使用Dictionary Literal创建字典</h2>

<pre><code class="language-text">var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]
</code></pre>

<h2 id="toc_15">迭代字典</h2>

<p>您可以用字典遍历键值对for- in环。字典中的每个项都作为元组返回，您可以将元组的成员分解为临时常量或变量，作为迭代的一部分：(key, value)</p>

<pre><code class="language-text">for (airportCode, airportName) in airports {
    print(&quot;\(airportCode): \(airportName)&quot;)
}
// LHR: London Heathrow
// YYZ: Toronto Pearson
</code></pre>

<h2 id="toc_16">Switch区间匹配</h2>

<p>switch可以检查案例中的值是否包含在间隔中。此示例使用数字间隔为任何大小的数字提供自然语言计数：</p>

<pre><code class="language-text">let approximateCount = 62
let countedThings = &quot;moons orbiting Saturn&quot;
let naturalCount: String
switch approximateCount {
case 0:
    naturalCount = &quot;no&quot;
case 1..&lt;5:
    naturalCount = &quot;a few&quot;
case 5..&lt;12:
    naturalCount = &quot;several&quot;
case 12..&lt;100:
    naturalCount = &quot;dozens of&quot;
case 100..&lt;1000:
    naturalCount = &quot;hundreds of&quot;
default:
    naturalCount = &quot;many&quot;
}
print(&quot;There are \(naturalCount) \(countedThings).&quot;)
// Prints &quot;There are doze
</code></pre>

<h2 id="toc_17">元组</h2>

<p>您可以使用元组在同一switch语句中测试多个值。可以针对不同的值或值的间隔来测试元组的每个元素。或者，使用下划线字符（_）（也称为通配符模式）来匹配任何可能的值。</p>

<p>下面的示例采用（x，y）点，表示为类型的简单元组，并将其分类在示例后面的图表上。(Int, Int)</p>

<pre><code class="language-text">let somePoint = (1, 1)
switch somePoint {
case (0, 0):
    print(&quot;\(somePoint) is at the origin&quot;)
case (_, 0):
    print(&quot;\(somePoint) is on the x-axis&quot;)
case (0, _):
    print(&quot;\(somePoint) is on the y-axis&quot;)
case (-2...2, -2...2):
    print(&quot;\(somePoint) is inside the box&quot;)
default:
    print(&quot;\(somePoint) is outside of the box&quot;)
}
// Prints &quot;(1, 1) is inside the box&quot;

</code></pre>

<h2 id="toc_18">Switch价值绑定</h2>

<p>一个switch情况下，可以将其命名为临时常量或变量，在案件的身体使用相匹配的一个或多个值。此行为称为值绑定，因为值绑定到案例正文中的临时常量或变量。</p>

<p>下面的示例采用（x，y）点，表示为类型的元组，并将其分类在下面的图表上：(Int, Int)</p>

<pre><code class="language-text">let anotherPoint = (2, 0)
switch anotherPoint {
case (let x, 0):
    print(&quot;on the x-axis with an x value of \(x)&quot;)
case (0, let y):
    print(&quot;on the y-axis with a y value of \(y)&quot;)
case let (x, y):
    print(&quot;somewhere else at (\(x), \(y))&quot;)
}
// Prints &quot;on the x-axis with an x value of 2&quot;


</code></pre>

<h2 id="toc_19">Switch-where</h2>

<p>一个switch情况下可以使用where子句来检查附加条件。</p>

<p>以下示例对下图中的（x，y）点进行了分类：</p>

<pre><code class="language-text">let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {
case let (x, y) where x == y:
    print(&quot;(\(x), \(y)) is on the line x == y&quot;)
case let (x, y) where x == -y:
    print(&quot;(\(x), \(y)) is on the line x == -y&quot;)
case let (x, y):
    print(&quot;(\(x), \(y)) is just some arbitrary point&quot;)
}
// Prints &quot;(1, -1) is on the line x == -y&quot;
</code></pre>

<h2 id="toc_20">Switch复合案例</h2>

<p>共享相同主体的多个开关盒可以通过case在每个模式之间用逗号后写几个模式来组合。如果任何模式匹配，则认为该情况匹配。如果列表很长，则可以在多行上写入模式。例如：</p>

<pre><code class="language-text">let someCharacter: Character = &quot;e&quot;
switch someCharacter {
case &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;:
    print(&quot;\(someCharacter) is a vowel&quot;)
case &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;,
     &quot;n&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;:
    print(&quot;\(someCharacter) is a consonant&quot;)
default:
    print(&quot;\(someCharacter) is not a vowel or a consonant&quot;)
}
// Prints &quot;e is a vowel&quot;

</code></pre>

<h2 id="toc_21">Switch复合案例包括值绑定</h2>

<p>复合案例的所有模式都必须包含同一组值绑定，并且每个绑定必须从复合案例中的所有模式中获取相同类型的值。这确保了，无论复合案例的哪个部分匹配，案例正文中的代码总是可以访问绑定的值，并且值始终具有相同的类型。</p>

<pre><code class="language-text">let stillAnotherPoint = (9, 0)
switch stillAnotherPoint {
case (let distance, 0), (0, let distance):
    print(&quot;On an axis, \(distance) from the origin&quot;)
default:
    print(&quot;Not on an axis&quot;)
}
// Prints &quot;On an axis, 9 from the origin&quot;
</code></pre>

<h2 id="toc_22">Swift-fallthrough</h2>

<p>在Swift中，switch语句不会落入每个案例的底部并进入下一个案例。也就是说，switch一旦第一个匹配的案例完成，整个语句就完成了它的执行。相反，C要求您break在每个switch案例的末尾插入一个明确的语句，以防止通过。避免默认的下降意味着Swift switch语句比C中的对应语句更简洁和可预测，因此它们避免switch错误地执行多个案例。</p>

<p>如果您需要C样式的直通行为，则可以使用fallthrough关键字逐个选择加入此行为。以下示例fallthrough用于创建数字的文本描述。</p>

<pre><code class="language-text">let integerToDescribe = 5
var description = &quot;The number \(integerToDescribe) is&quot;
switch integerToDescribe {
case 2, 3, 5, 7, 11, 13, 17, 19:
    description += &quot; a prime number, and also&quot;
    fallthrough
default:
    description += &quot; an integer.&quot;
}
print(description)
// Prints &quot;The number 5 is a prime number, and also an integer.&quot;

</code></pre>

<h2 id="toc_23">检查API可用性</h2>

<p>Swift内置支持检查API可用性，这可确保您不会意外使用在给定部署目标上不可用的API。</p>

<p>编译器使用SDK中的可用性信息来验证代码中使用的所有API是否在项目指定的部署目标上可用。如果您尝试使用不可用的API，Swift会在编译时报告错误。</p>

<p>您可以在or 语句中使用可用性条件来有条件地执行代码块，具体取决于您要使用的API是否在运行时可用。当编译器验证该代码块中的API可用时，编译器将使用可用性条件中的信息。ifguard</p>

<pre><code class="language-text">if #available(iOS 10, macOS 10.12, *) {
    // Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS
} else {
    // Fall back to earlier iOS and macOS APIs
}

</code></pre>

<h2 id="toc_24">具有隐含回报的函数</h2>

<p>如果函数的整个主体是单个表达式，则该函数隐式返回该表达式。例如，下面的两个函数都具有相同的行为：</p>

<pre><code class="language-text">func greeting(for person: String) -&gt; String {
    &quot;Hello, &quot; + person + &quot;!&quot;
}
print(greeting(for: &quot;Dave&quot;))
// Prints &quot;Hello, Dave!&quot;

func anotherGreeting(for person: String) -&gt; String {
    return &quot;Hello, &quot; + person + &quot;!&quot;
}
print(anotherGreeting(for: &quot;Dave&quot;))
// Prints &quot;Hello, Dave!&quot;

</code></pre>

<h2 id="toc_25">可变参数</h2>

<p>函数可以具有至多一个可变参数。</p>

<p>可变参数参数接受具有指定类型的零倍或更多的值。您可以使用variadic参数指定在调用函数时可以向参数传递不同数量的输入值。通过...在参数的类型名称后面插入三个句点字符（）来编写可变参数。</p>

<p>传递给可变参数的值在函数体内可用作适当类型的数组。例如，在函数体内可以使用名称numbers和类型的可变参数Double...作为名为numberstype 的常量数组[Double]。</p>

<p>下面的示例计算任意长度的数字列表的算术平均值（也称为平均值）：</p>

<pre><code class="language-text">func arithmeticMean(_ numbers: Double...) -&gt; Double {
    var total: Double = 0
    for number in numbers {
        total += number
    }
    return total / Double(numbers.count)
}
arithmeticMean(1, 2, 3, 4, 5)
// returns 3.0, which is the arithmetic mean of these five numbers
arithmeticMean(3, 8.25, 18.75)
// returns 10.0, which is the arithmetic mean of these three numbers
</code></pre>

<h2 id="toc_26">进出参数</h2>

<p>默认情况下，函数参数是常量。尝试从该函数体内更改函数参数的值会导致编译时错误。这意味着您无法错误地更改参数的值。如果希望函数修改参数的值，并且希望在函数调用结束后这些更改仍然存在，请将该参数定义为输入输出参数。</p>

<p>您只能将变量作为输入输出参数的参数传递。您不能传递常量或文字值作为参数，因为不能修改常量和文字。&amp;当您将变量名称作为参数传递给输入输出参数时，可以将变量名称直接放在变量名称之前，以指示它可以被函数修改。</p>

<p>输入输出参数不能具有默认值，并且不可变参数不能标记为inout。</p>

<p>这是一个名为的函数示例swapTwoInts(_:_:)，它有两个输入输出的整数参数，a并且b：</p>

<pre><code class="language-text">func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>

<p>该swapTwoInts(_:_:)函数简单地交换binto a的值和ainto 的值b。该函数通过将值存储a在一个被调用的临时常量temporaryA，指定bto 的值a，然后分配给它temporaryA来执行此交换b。</p>

<p>您可以swapTwoInts(_:_:)使用两个类型的变量调用该函数Int来交换它们的值。请注意，传递给函数时，someInt和的名称anotherInt前缀为＆符号swapTwoInts(_:_:)：</p>

<pre><code class="language-text">var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;someInt, &amp;anotherInt)
print(&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;)
// Prints &quot;someInt is now 107, and anotherInt is now 3&quot;
</code></pre>

<p>上面的示例显示函数的原始值someInt和anotherInt由swapTwoInts(_:_:)函数修改，即使它们最初是在函数外部定义的。</p>

<p>输入输出参数与从函数返回值不同。swapTwoInts上面的示例没有定义返回类型或返回值，但它仍然修改了someInt和的值anotherInt。输入输出参数是函数在其函数体范围之外产生效果的另一种方法。</p>

<h2 id="toc_27">嵌套函数</h2>

<p>到目前为止，您在本章中遇到的所有函数都是全局函数的示例，这些函数在全局范围内定义。您还可以在其他函数体内定义函数，称为嵌套函数。</p>

<p>默认情况下，嵌套函数对外界是隐藏的，但它们的封闭函数仍然可以调用它们。封闭函数也可以返回其嵌套函数之一，以允许嵌套函数在另一个范围内使用。</p>

<p>您可以重写chooseStepFunction(backward:)上面的示例以使用和返回嵌套函数：</p>

<pre><code class="language-text">func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {
    func stepForward(input: Int) -&gt; Int { return input + 1 }
    func stepBackward(input: Int) -&gt; Int { return input - 1 }
    return backward ? stepBackward : stepForward
}
var currentValue = -4
let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)
// moveNearerToZero now refers to the nested stepForward() function
while currentValue != 0 {
    print(&quot;\(currentValue)... &quot;)
    currentValue = moveNearerToZero(currentValue)
}
print(&quot;zero!&quot;)
// -4...
// -3...
// -2...
// -1...
// zero!

</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/12/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509809415.html">
                
                  <h1>一个实例对象可以通过4种方式调用其方法。</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<pre><code class="language-text">- (void)test{
    
//type1
    [self printStr1:@&quot;hello world 1&quot;];
    
//type2
    [self performSelector:@selector(printStr1:) withObject:@&quot;hello world 2&quot;];
    
//type3
    //获取方法签名
    NSMethodSignature *sigOfPrintStr = [self methodSignatureForSelector:@selector(printStr1:)];
    
    //获取方法签名对应的invocation
    NSInvocation *invocationOfPrintStr = [NSInvocation invocationWithMethodSignature:sigOfPrintStr];
    
    /**
    设置消息接受者，与[invocationOfPrintStr setArgument:(__bridge void * _Nonnull)(self) atIndex:0]等价
    */
    [invocationOfPrintStr setTarget:self];
    
    /**设置要执行的selector。与[invocationOfPrintStr setArgument:@selector(printStr1:) atIndex:1] 等价*/
    [invocationOfPrintStr setSelector:@selector(printStr1:)];
    
    //设置参数 
    NSString *str = @&quot;hello world 3&quot;;
    [invocationOfPrintStr setArgument:&amp;str atIndex:2];
    
    //开始执行
    [invocationOfPrintStr invoke];
    
    //type4
    ((void (*)(id,SEL,NSString *, NSArray *, NSInteger))objc_msgSend)(self, @selector(textFunctionWithParam:param2:param3:),@&quot;111&quot;,@[@2,@3],123);

}
-(void)textFunctionWithParam:(NSString *)param1 param2:(NSArray *)param2 param3:(NSInteger)param3 {
    NSLog(@&quot;param1:%@, param2:%@, param3:%ld&quot;,param1, param2, param3);
}
- (void)printStr1:(NSString*)str{
    NSLog(@&quot;printStr1  %@&quot;,str);
}


</code></pre>

<h2 id="toc_0">下面展示block 的两种调用方式</h2>

<pre><code class="language-text">- (void)test{

    void (^block1)(int) = ^(int a){
         NSLog(@&quot;block1 %d&quot;,a);
    };
    
    //type1
    block1(1);
    
    //type2
    //获取block类型对应的方法签名。
    NSMethodSignature *signature = aspect_blockMethodSignature(block1);
    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];
    [invocation setTarget:block1];
    int a=2;
    [invocation setArgument:&amp;a atIndex:1];
    [invocation invoke];
}

</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/12/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509809509.html">
                
                  <h1>block</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>如果使用weak修饰block，那么将有可能出现野指针的错误问题</p>

<p>那么strong 和 copy 有什么区别呢 </p>

<p>block本身是像对象一样可以r****etain，和release。但是，block在创建的时候，它的内存是分配在栈上的，而不是在堆上。他本身的作于域是属于创建时候的作用域，一旦在创建时候的作用域外面调用block将导致程序崩溃。因为栈区的特点就是创建的对象随时可能被销毁,一旦被销毁后续再次调用空对象就可能会造成程序崩溃,在对block进行copy后,block存放在堆区.<br/>
使用retain也可以，但是block的retain行为默认是用copy的行为实现的，<br/>
因为block变量默认是声明为栈变量的，为了能够在block的声明域外使用，所以要把block拷贝（copy）到堆，所以说为了block属性声明和实际的操作一致，最好声明为copy。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/12/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509809545.html">
                
                  <h1>Autorelease Pool 的用处</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在 ARC 下，我们并不需要手动调用 autorelease 有关的方法，甚至可以完全不知道 autorelease 的存在，就可以正确管理好内存。因为 Cocoa Touch 的 Runloop 中，每个 runloop circle 中系统都自动加入了 Autorelease Pool 的创建和释放。</p>

<p>当我们需要创建和销毁大量的对象时，使用手动创建的 autoreleasepool 可以有效的避免内存峰值的出现。因为如果不手动创建的话，外层系统创建的 pool 会在整个 runloop circle 结束之后才进行 drain，手动创建的话，会在 block 结束之后就进行 drain 操作。详情请参考苹果官方文档。一个普遍被使用的例子如下：</p>

<pre><code class="language-text">for (int i = 0; i &lt; 100000000; i++)
{
    @autoreleasepool
    {
        NSString* string = @&quot;ab c&quot;;
        NSArray* array = [string componentsSeparatedByString:string];
    }
}
</code></pre>

<p>如果不使用 autoreleasepool ，需要在循环结束之后释放 100000000 个字符串，如果<br/>
使用的话，则会在每次循环结束的时候都进行 release 操作。</p>

<h2 id="toc_0">Autorelease Pool 进行 Drain 的时机</h2>

<p>如上面所说，系统在 runloop 中创建的 autoreleaspool 会在 runloop 一个 event 结束时进行释放操作。我们手动创建的 autoreleasepool 会在 block 执行完成之后进行 drain 操作。需要注意的是：</p>

<p>当 block 以异常（exception）结束时，pool 不会被 drain</p>

<p>Pool 的 drain 操作会把所有标记为 autorelease 的对象的引用计数减一，但是并不意味着这个对象一定会被释放掉，我们可以在 autorelease pool 中手动 retain 对象，以延长它的生命周期（在 MRC 中）。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/12/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_11.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_13.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="/Users/cnsunrun/Desktop/507369_large.png" /></div>
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">










<a target="_blank" class="email" href="mailto:maweefeng@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="%E7%94%B5%E5%BD%B1.html"><strong>电影</strong></a>
        
            <a href="%E5%85%B6%E5%AE%83.html"><strong>其它</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="iOS.html"><strong>iOS</strong></a>
        
            <a href="%E6%88%91.html"><strong>我</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16076509803956.html">Xcode10报错libstdc</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16076509804011.html">Masonry布局“Unable to simultaneously satisfy constraints”</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16076509804045.html">RACCommand</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16076509804076.html">代理修饰符</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16076509804110.html">You don’t have write permissions</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
