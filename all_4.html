<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
  
  
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="%E7%94%B5%E5%BD%B1.html">电影</a></li>
        
            <li><a href="%E5%85%B6%E5%AE%83.html">其它</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="iOS.html">iOS</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="16076509806241.html">
                
                  <h1>Python</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">另类创建字典的方法</h2>

<ul>
<li><p>zip函数</p>
<pre><code class="language-text">names = [&#39;name&#39;,&#39;age&#39;,&#39;pay&#39;,&#39;job&#39;]
values = [&#39;sam smith&#39;,40,3000,&#39;software&#39;]<br/>
print(list(zip(names,values)))
</code></pre></li>
<li><p>创建空字典</p>
<pre><code class="language-text">names = [&#39;name&#39;,&#39;age&#39;,&#39;pay&#39;,&#39;job&#39;]
record = dict.fromkeys(names,&quot;?&quot;)<br/>
print(record)
</code></pre></li>
</ul>

<h2 id="toc_1">路径</h2>

<p>os.sys.path[0]获取当前 path 文件所在的文件夹<br/>
os.sys.argv[0]获取当前 path 文件的绝对路径</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/12</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python.html'>Python</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509804138.html">
                
                  <h1>隐藏导航栏底部的线条</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>有时候遇到一些特殊的要求，需要隐藏导航栏底部的线条。<br/>
两行代码就可以做到。</p>

<ul>
<li>方法一:<br/>
设置导航栏的背景图（setBackgroundImage方法）<br/>
设置导航栏的shadowImage (setShadowImage方法)<br/></li>
</ul>

<pre><code class="language-text">UINavigationBar *navigationBar = self.navigationController.navigationBar;    
</code></pre>

<p>//设置透明的背景图，便于识别底部线条有没有被隐藏    </p>

<pre><code class="language-text">[navigationBar setBackgroundImage:[[UIImage alloc] init]
                       forBarPosition:UIBarPositionAny
                           barMetrics:UIBarMetricsDefault]; 
</code></pre>

<p>//此处使底部线条失效</p>

<pre><code class="language-text">[navigationBar setShadowImage:[UIImage new]];
</code></pre>

<ul>
<li>方法二：</li>
</ul>

<pre><code class="language-text">self.navigationController.navigationBar.clipsToBounds = YES; 
</code></pre>

<h3 id="toc_0">导航栏全局属性设置</h3>

<p>//全局设置导航栏主题</p>

<pre><code class="language-text">- (void)setNavigationControllerAppearance {
    [UINavigationBar appearance].barStyle  = UIBarStyleBlack;
    [[UINavigationBar appearance] setBarTintColor:[UIColor colorWithWhite:0.1 alpha:0.5]];
    [[UINavigationBar appearance] setTintColor:[UIColor whiteColor]];
}

</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509804464.html">
                
                  <h1>终端命令设置代理</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4 id="toc_0">让终端走代理的几种方法</h4>

<p><code>Macproxyterminal</code></p>

<ul>
<li><p>方法1:<br/>
在终端中直接运行命令<br/>
export http_proxy=<a href="http://proxyAddress:port">http://proxyAddress:port</a><br/>
这个办法的好处是简单直接，并且影响面很小（只对当前终端有效，退出就不行了）。<br/>
如果你用的是ss代理，在当前终端运行以下命令，那么wget curl 这类网络命令都会经过ss代理<br/>
export ALL_PROXY=socks5://127.0.0.1:1080</p></li>
<li><p>方法2:<br/>
比如我现在使用的shadowsocks工具可以直接设置全局代理，勾选就行了，一般使用的是PAC自动模式，这样可以根据条件选择代理or直连，保证速度和网站的可达性。</p></li>
</ul>

<p><img src="media/15427834491808/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%20%E4%B8%8B%E5%8D%881.09.57.png" alt="屏幕快照 2018-12-04 下午1.09.57"/><br/>
shadowSocks软件的Git地址为<a href=""><code>https://github.com/shadowsocks/ShadowsocksX-NG</code></a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%85%B6%E5%AE%83.html'>其它</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509804590.html">
                
                  <h1>pod install速度过慢</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>①代理VPN方式</li>
</ul>

<p>相信大家已经感受到<code>pod install</code>速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。</p>

<p>使用国内镜像的<code>Specs</code><br/>
在<code>pod install</code>时使用命令<code>pod install --no-repo-update</code><br/>
使用<code>proxychains</code>使终端命令走代理<br/>
下面就来说明一下这几种方法为何没有完全解决问题</p>

<p>使用国内镜像的<code>Specs</code> 极大地加快了<code>Specs</code>下载更新速度，而且如果使用国内镜像<code>Specs</code>，那么<code>Podfile</code>中就必须指明使用这个<code>Specs</code>。<br/>
在<code>pod install</code>时使用命令<code>pod install --no-repo-update</code>时不更新本地库，但如果第一次<code>install</code>还是要去<code>github clone</code>代码<br/>
使用<code>proxychains</code>使终端命令走代理 <br/>
这个只是使pod命令走代理，<code>git download</code>的时候不会走代理<br/>
其实真正慢的原因并不在pod命令，而是在于github上的代码库访问速度慢，那么就知道真正的解决方案就是要加快git命令的速度。 <br/>
我使用Shadowsocks代理，默认代理端口为1080，配置好代理之后去终端输入git配置命令，命令如下</p>

<p><code>git config --global http.proxy socks5://127.0.0.1:1080</code></p>

<p>上面的命令是给git设置全局代理，但是我们并不希望国内git库也走代理，而是只需要github上的代码库走代理，命令如下</p>

<p><code>git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</code></p>

<p>ps：如果要恢复/移除上面设置的git代理，使用如下命令</p>

<pre><code class="language-text">git config --global --unset http.proxy
git config --global --unset http.https://github.com.proxy
</code></pre>

<ul>
<li>②更改host</li>
</ul>

<pre><code class="language-text">执行下面的操作会使整个过程更快一些

* 进入网址https://www.ipaddress.com/
* 输入 gitHub.com 找到GitHub的ip地址 
* 然后打开hosts (打开hosts的操作是`sudo vim /etc/hosts`)添加 ip http://github.com
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%85%B6%E5%AE%83.html'>其它</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509808874.html">
                
                  <h1>xpath 提取div标签所有文字信息</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><img src="media/15591149863353/15591150079270.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python.html'>Python</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509808368.html">
                
                  <h1>RunLoop</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Fundation 框架是对Core Fundation的封装。</p>

<h2 id="toc_0">Fundation</h2>

<p><code>[NSRunLoop currentRunLoop];</code>//返回当前线程的RunLoop  如果不存在就会创建一个RunLoop并返回。<br/>
//If a run loop does not yet exist for the thread, one is created and returned.</p>

<p><code>[NSRunLoop mainRunLoop]</code>//获取主线程的RunLoop对象。</p>

<p>基础知识:每个线程上都对应有一个RunLoop对象，主线程RunLoop默认开启，子线程RunLoop要手动开启。<br/>
RunLoop在线程结束的时候退出循环。</p>

<h2 id="toc_1">Core Fundation</h2>

<p><code>CFRunLoopGetCurrent()</code>//<br/>
获取当前线程的RunLoop对象</p>

<p><code>CFRunloopGetMain()</code>//获取主线程的RunLoop对象</p>

<h4 id="toc_2">CFRunLoopModeRef</h4>

<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g3chptv14yj30y60u0ju5.jpg" alt="runloop@3x"/><br/>
每个 RunLoop其实都是一个对象，可以包含多个不同的 Mode，每个Mode又由Source、Observer、 Timer组成，而且Mode中Source、Observer、 Timer都不存在的话，这个RunLoop也不存在。</p>

<p>系统默认注册了5个Mode</p>

<ul>
<li><p>kCFRunLoopDeafultMode:App的默认mode。通常主线程是在这个mode下运行。</p></li>
<li><p>UITrakingRunLoopMode:界面跟踪mode 用于scrollview追踪触摸滑动，保证界面滑动时不受其他mode的影响。</p></li>
<li><p>UIInitalizeationRunloopMode:在刚启动app时进入的第一个mode 启动完成后就不再使用。</p></li>
<li><p>GSEventReceiveRunLoopMode:接受系统时间的内部mode 通常用不到</p></li>
<li><p>kCFRunLoopCommonModes:这是一个占位用的mode 不是一种真正的mode</p></li>
</ul>

<h4 id="toc_3">CFRunLoopSourceRef</h4>

<p>事件源（输入源）</p>

<ul>
<li><p>source0 非基于port的</p>
<ul>
<li>custom input sources</li>
<li>cocoa perform selector sources</li>
</ul></li>
<li><p>source1 基于port的</p>
<ul>
<li>port-based sources </li>
</ul></li>
</ul>

<h4 id="toc_4">CFRunLoopTimerRef</h4>

<blockquote>
<p>基于时间的触发器</p>
</blockquote>

<p>基本上说的就是NSTimer<br/>
默认加到kCFRunLoopDeafultMode 但是滑动的时候定时器所在的mode会暂停，所以应该把定时器加到kCFRunLoopCommonModes中去。</p>

<pre><code class="language-text">//创建定时器并开启定时任务
+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;
//创建定时器但不开启定时任务
+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;
</code></pre>

<p>NSTimer中<code>scheduledTimerWithTimeInterval</code>方法创建的默认加到<code>kCFRunLoopDeafultMode</code>并开启，但是其他方法创建的定时器并没有开启，要去手动开启，或者直接指定一个mode，那么就会开启执行定时器任务。</p>

<h4 id="toc_5">CFRunLoopObserverRef</h4>

<blockquote>
<p>观察者，能够监听runloop的状态改变。</p>
</blockquote>

<p>可以监听的时间点有以下几个。</p>

<pre><code class="language-text">/* Run Loop Observer Activities */
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry = (1UL &lt;&lt; 0),即将进入runloop
    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),即将处理timer
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),即将处理source
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),即将进入休眠
    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),刚从休眠中唤醒
    kCFRunLoopExit = (1UL &lt;&lt; 7),即将退出runloop
    kCFRunLoopAllActivities = 0x0FFFFFFFU监听runloop所有的情况
};
</code></pre>

<pre><code class="language-text">//添加runloop状态的监听
-(void)addobserver{
    
    CFRunLoopObserverRef observe = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {
        
        NSLog(@&quot;%lu&quot;,activity);
    });
    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observe, kCFRunLoopDefaultMode);
}

CFRelease(observe);//记得要释放c中的对象


</code></pre>

<h2 id="toc_6">实战场景</h2>

<p>Q:当滑动的时候对imageview设置图片并不会显示。</p>

<p>A:所以可以使设置image的操作在commonmode中执行。</p>

<p>比如使用方法</p>

<pre><code class="language-text">UIImageView * imageView = [[UIImageView alloc]init];

[imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;logo&quot;] afterDelay:3 inModes:@[NSRunLoopCommonModes]];
</code></pre>

<hr/>

<p>Q:当滑动的时候Timer的定时任务不会执行。</p>

<p>A:把Timer放到commonmode中执行。</p>

<p>比如使用方法</p>

<pre><code class="language-text"> NSTimer * timer =   [NSTimer scheduledTimerWithTimeInterval:2 repeats:YES block:^(NSTimer * _Nonnull timer) {
    }];
    
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
</code></pre>

<hr/>

<p>创建子线程并执行事件，任务做完之后线程就销毁了。</p>

<pre><code class="language-text">-(void)creatThread{
    
    NSThread * thread = [[NSThread alloc]initWithTarget:self selector:@selector(testThread) object:nil];
    
    [thread start];
}

-(void)testThread{
      
    NSLog(@&quot;%@&quot;,[NSThread currentThread]);
    
}
</code></pre>

<hr/>

<p>Q:如果想要让这个线程常驻的话应该怎么操作呢</p>

<p>A:创建一个带有mode的runloop并开启，runloop如果不指定mode的话就不能开启循环。</p>

<p>比如使用方法</p>

<pre><code class="language-text">-(void)creatThread{
    
    NSThread * thread = [[NSThread alloc]initWithTarget:self selector:@selector(testThread) object:nil];
    [thread start];
}

-(void)testThread{
    
    NSLog(@&quot;%@&quot;,[NSThread currentThread]);
    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];
    [[NSRunLoop currentRunLoop] run];
    //这个代码不会往下执行，所以这个任务不会结束。
}
</code></pre>

<hr/>

<p>Q:如果子线程加一个定时器任务，定时器任务不执行</p>

<p>A:在主线程开启的定时器默认开启了runloop，但是子线程开启的定时器没有runloop需要手动开启。</p>

<pre><code class="language-text">-(void)creatThread{
    
    self.thread = [[NSThread alloc]initWithTarget:self selector:@selector(testTimer) object:nil];
    [_thread start];
  
}
//修改前
-(void)testTimer{
    
    [NSTimer scheduledTimerWithTimeInterval:2 repeats:YES block:^(NSTimer * _Nonnull timer) {
       
        //code
    }];
}
//修改后
-(void)testTimer{
    
    [NSTimer scheduledTimerWithTimeInterval:2 repeats:YES block:^(NSTimer * _Nonnull timer) {
       
        //code
    }];
    1.[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];
    //还可以使用下面这个方法，但是注意到如果是使用的schedue创建的方法默认是把timer加到runloop的只需要把当前的runloop run就可以了不需要再加1和2的方法，但是其他创建timer的方法没有默认把timer加到runloop就必须使用下面的这个方法把timer加到runloop当中。    
    2.[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
    //必须的方法，因为子线程创建的runloop需要手动开启。
    [[NSRunLoop currentRunLoop] run];
}
</code></pre>

<p>没有开启runloop线程被销毁了，定时器也没有被加到runloop执行，所以解决办法就是把定时器加到runloop当中的mode中并执行run方法。</p>

<hr/>

<p>自动释放池</p>

<pre><code class="language-text">//当runloop在休眠之前会释放自动释放池，当runloop再启动时就会再创建池子
@autoreleasepool {
        [NSTimer scheduledTimerWithTimeInterval:2 repeats:YES block:^(NSTimer * _Nonnull timer) {
            //code
        }];
        
        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];
        [[NSRunLoop currentRunLoop] run];
    }

</code></pre>

<p>runloop休眠的时候自动释放池销毁，在启动的时候再次生成自动释放池。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509809222.html">
                
                  <h1>记录swift 当中超出以前认知的知识点</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">支持unicode编码的变量值</h2>

<pre><code class="language-text">let a = [Int]()
let 🐶🐮 = &quot;dogcow&quot;
let 你好 = &quot;你好世界&quot;
</code></pre>

<h2 id="toc_1">错误处理</h2>

<p>您使用错误处理来响应程序在执行期间可能遇到的错误情况。</p>

<p>与可以使用值的存在或不存在来传递函数成功或失败的选项相比，错误处理允许您确定失败的根本原因，并在必要时将错误传播到程序的另一部分。</p>

<p>当函数遇到错误条件时，它会抛出错误。然后该函数的调用者可以捕获错误并做出适当的响应。</p>

<pre><code class="language-text">func canThrowAnError() throws {
    // this function may or may not throw an error
}
</code></pre>

<p>函数表示它可以通过throws在其声明中包含关键字来引发错误。当您调用可以抛出错误的函数时，您可以将try关键字添加到表达式中。</p>

<p>Swift会自动将错误传播出当前作用域，直到它们被catch子句处理。</p>

<pre><code class="language-text">do {
    try canThrowAnError()
    // no error was thrown
} catch {
    // an error was thrown
}
</code></pre>

<p>一个do语句创建一个新的包含范围，允许误差传播到一个或多个catch条款。</p>

<p>以下是如何使用错误处理来响应不同错误条件的示例：</p>

<pre><code class="language-text">func makeASandwich() throws {
    // ...
}

do {
    try makeASandwich()
    eatASandwich()
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)
}
</code></pre>

<p>在此示例中，makeASandwich()如果没有可用的干净菜肴或缺少任何成分，该函数将抛出错误。因为makeASandwich()可以抛出错误，函数调用包含在try表达式中。通过将函数调用包装在do语句中，抛出的任何错误都将传播到提供的catch子句。</p>

<p>如果没有抛出错误，eatASandwich()则调用该函数。如果抛出错误并且它与SandwichError.outOfCleanDishes大小写匹配，则将washDishes()调用该函数。如果抛出错误并且它与SandwichError.missingIngredients大小写匹配，则buyGroceries(_:)调用该函数，并使用模式[String]捕获的关联值catch。</p>

<p>错误处理中更详细地介绍了抛出，捕获和传播错误。</p>

<h2 id="toc_2">一元减号算子</h2>

<p>可以使用前缀-（称为一元减号运算符）来切换数值的符号：</p>

<pre><code class="language-text">let three = 3
let minusThree = -three       // minusThree equals -3
let plusThree = -minusThree   // plusThree equals 3, or &quot;minus minus three&quot;
</code></pre>

<p>一元减号运算符（-）直接位于它运行的值之前，没有任何空格。</p>

<h2 id="toc_3">一元加运算符</h2>

<p>在一元加运算（+）只返回其所操作的价值，没有任何变化：</p>

<pre><code class="language-text">let minusSix = -6
let alsoMinusSix = +minusSix  // alsoMinusSix equals -6
</code></pre>

<p>虽然一元加运算符实际上没有做任何事情，但是当使用一元减运算符作为负数时，您可以使用它来为代码提供正数的对称性。</p>

<h2 id="toc_4">闭区域操作员</h2>

<p>的封闭范围操作符（a...b）限定了从运行范围a来b，并且包括这些值a和b。值a不得大于b。</p>

<p>当在您希望使用所有值的范围内进行迭代时，闭环范围运算符非常有用，例如使用for- in循环：</p>

<pre><code class="language-text">for index in 1...5 {
    print(&quot;\(index) times 5 is \(index * 5)&quot;)
}
// 1 times 5 is 5
// 2 times 5 is 10
// 3 times 5 is 15
// 4 times 5 is 20
// 5 times 5 is 25
</code></pre>

<p>有关for- in循环的更多信息，请参阅控制流。</p>

<h2 id="toc_5">半开放式操作员</h2>

<p>所述半开区间运算符（a..&lt;b）限定了从运行范围a到b，但不包括b。它被认为是半开放的，因为它包含它的第一个值，但不是它的最终值。与闭区域运算符一样，值a不得大于b。如果值a等于b，则结果范围将为空。</p>

<p>当您使用基于零的列表（如数组）时，半开范围特别有用，其中计算列表的长度（但不包括）非常有用：</p>

<pre><code class="language-text">let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]
let count = names.count
for i in 0..&lt;count {
    print(&quot;Person \(i + 1) is called \(names[i])&quot;)
}
// Person 1 is called Anna
// Person 2 is called Alex
// Person 3 is called Brian
// Person 4 is called Jack
</code></pre>

<p>请注意，该数组包含四个项目，但0..&lt;count只计算3（数组中最后一项的索引），因为它是半开放范围。有关数组的更多信息，请参阅数组。</p>

<h2 id="toc_6">单面范围</h2>

<p>闭区域运算符有一个替代形式，用于在一个方向上尽可能继续的范围 - 例如，包括从索引2到数组末尾的数组的所有元素的范围。在这些情况下，您可以省略范围运算符一侧的值。这种范围称为单侧范围，因为操作员仅在一侧具有值。例如：</p>

<pre><code class="language-text">for name in names[2...] {
    print(name)
}
// Brian
// Jack

for name in names[...2] {
    print(name)
}
// Anna
// Alex
// Brian
</code></pre>

<p>半开放范围操作符也具有单侧形式，仅使用其最终值编写。就像在两侧都包含值一样，最终值不是范围的一部分。例如：</p>

<pre><code class="language-text">for name in names[..&lt;2] {
    print(name)
}
// Anna
// Alex
</code></pre>

<p>单边范围可以在其他上下文中使用，而不仅仅在下标中使用。您不能迭代忽略第一个值的单侧范围，因为不清楚迭代应该从哪里开始。您可以迭代忽略其最终值的单侧范围; 但是，因为范围无限期地继续，请确保为循环添加显式结束条件。您还可以检查单侧范围是否包含特定值，如下面的代码所示。</p>

<pre><code class="language-text">let range = ...5
range.contains(7)   // false
range.contains(4)   // true
range.contains(-1)  // true
</code></pre>

<h3 id="toc_7">数组元素下标和值的对应关系</h3>

<p>如果需要每个项的整数索引及其值，请使用该enumerated()方法迭代数组。对于数组中的每个项，该enumerated()方法返回由整数和项组成的<code>元组</code>。整数从零开始，每个项目加1; 如果枚举整个数组，则这些整数与项目的索引相匹配。您可以将元组分解为临时常量或变量，作为迭代的一部分：</p>

<pre><code class="language-text">for (index, value) in shoppingList.enumerated() {
    print(&quot;Item \(index + 1): \(value)&quot;)
}
</code></pre>

<h2 id="toc_8">布尔值类型不能比较大小，元祖也是可以比较大小的。</h2>

<h2 id="toc_9">创建和初始化空集</h2>

<p>您可以使用初始化程序语法创建某个类型的空集：</p>

<pre><code class="language-text">var letters = Set&lt;Character&gt;()
</code></pre>

<p>Swift集的类型写为Set<Element>，Element允许集存储的类型在哪里。与数组不同，集合没有等效的简写形式</p>

<h2 id="toc_10">Set是一个无序的不重复元素的集合</h2>

<p>Swift的Set类型没有定义的顺序。要以特定顺序迭代集合的值，请使用该sorted()方法，该方法将集合的元素作为使用&lt;运算符排序的数组返回。</p>

<pre><code class="language-text">for genre in favoriteGenres.sorted() {
    print(&quot;\(genre)&quot;)
}
// Classical
// Hip hop
// Jazz
</code></pre>

<h2 id="toc_11">使用Array Literal创建集合</h2>

<p>您还可以使用数组文字初始化集合，作为将一个或多个值写为集合集合的简写方式。</p>

<p>下面的示例创建一个名为favoriteGenres存储String值的集合：</p>

<pre><code class="language-text">var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
// favoriteGenres has been initialized with three initial items
</code></pre>

<h2 id="toc_12">Set基本集合运算</h2>

<p><img src="https://docs.swift.org/swift-book/_images/setVennDiagram_2x.png" alt=""/></p>

<ul>
<li>使用该intersection(_:)方法创建一个仅包含两个集合共有值的新集合。</li>
<li>使用该symmetricDifference(_:)方法创建一个新集合，其中包含任一集合中的值，但不能同时创建两者。</li>
<li>使用该union(_:)方法创建包含两个集中所有值的新集。</li>
<li>使用此subtracting(_:)方法创建一个值不在指定集中的新集。</li>
</ul>

<pre><code class="language-text">let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]

oddDigits.union(evenDigits).sorted()
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
oddDigits.intersection(evenDigits).sorted()
// []
oddDigits.subtracting(singleDigitPrimeNumbers).sorted()
// [1, 9]
oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()
// [1, 2, 9]
</code></pre>

<ul>
<li>使用“is equal”运算符（==）来确定两个集合是否包含所有相同的值。</li>
<li>使用此isSubset(of:)方法确定集合的所有值是否都包含在指定的集合中。</li>
<li>使用此isSuperset(of:)方法确定集合是否包含指定集合中的所有值。</li>
<li>使用isStrictSubset(of:)或isStrictSuperset(of:)方法确定集合是否是指定集合的​​子集或超集，但不等于。</li>
<li>使用该isDisjoint(with:)方法确定两个集合是否没有共同的值。</li>
</ul>

<pre><code class="language-text">let houseAnimals: Set = [&quot;🐶&quot;, &quot;🐱&quot;]
let farmAnimals: Set = [&quot;🐮&quot;, &quot;🐔&quot;, &quot;🐑&quot;, &quot;🐶&quot;, &quot;🐱&quot;]
let cityAnimals: Set = [&quot;🐦&quot;, &quot;🐭&quot;]

houseAnimals.isSubset(of: farmAnimals)
// true
farmAnimals.isSuperset(of: houseAnimals)
// true
farmAnimals.isDisjoint(with: cityAnimals)
// true
</code></pre>

<h2 id="toc_13">创建一个空字典</h2>

<p>与数组一样，您可以Dictionary使用初始化程序语法创建某个类型的空：</p>

<pre><code class="language-text">var namesOfIntegers = [Int: String]()
// namesOfIntegers is an empty [Int: String] dictionary
</code></pre>

<h2 id="toc_14">使用Dictionary Literal创建字典</h2>

<pre><code class="language-text">var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]
</code></pre>

<h2 id="toc_15">迭代字典</h2>

<p>您可以用字典遍历键值对for- in环。字典中的每个项都作为元组返回，您可以将元组的成员分解为临时常量或变量，作为迭代的一部分：(key, value)</p>

<pre><code class="language-text">for (airportCode, airportName) in airports {
    print(&quot;\(airportCode): \(airportName)&quot;)
}
// LHR: London Heathrow
// YYZ: Toronto Pearson
</code></pre>

<h2 id="toc_16">Switch区间匹配</h2>

<p>switch可以检查案例中的值是否包含在间隔中。此示例使用数字间隔为任何大小的数字提供自然语言计数：</p>

<pre><code class="language-text">let approximateCount = 62
let countedThings = &quot;moons orbiting Saturn&quot;
let naturalCount: String
switch approximateCount {
case 0:
    naturalCount = &quot;no&quot;
case 1..&lt;5:
    naturalCount = &quot;a few&quot;
case 5..&lt;12:
    naturalCount = &quot;several&quot;
case 12..&lt;100:
    naturalCount = &quot;dozens of&quot;
case 100..&lt;1000:
    naturalCount = &quot;hundreds of&quot;
default:
    naturalCount = &quot;many&quot;
}
print(&quot;There are \(naturalCount) \(countedThings).&quot;)
// Prints &quot;There are doze
</code></pre>

<h2 id="toc_17">元组</h2>

<p>您可以使用元组在同一switch语句中测试多个值。可以针对不同的值或值的间隔来测试元组的每个元素。或者，使用下划线字符（_）（也称为通配符模式）来匹配任何可能的值。</p>

<p>下面的示例采用（x，y）点，表示为类型的简单元组，并将其分类在示例后面的图表上。(Int, Int)</p>

<pre><code class="language-text">let somePoint = (1, 1)
switch somePoint {
case (0, 0):
    print(&quot;\(somePoint) is at the origin&quot;)
case (_, 0):
    print(&quot;\(somePoint) is on the x-axis&quot;)
case (0, _):
    print(&quot;\(somePoint) is on the y-axis&quot;)
case (-2...2, -2...2):
    print(&quot;\(somePoint) is inside the box&quot;)
default:
    print(&quot;\(somePoint) is outside of the box&quot;)
}
// Prints &quot;(1, 1) is inside the box&quot;

</code></pre>

<h2 id="toc_18">Switch价值绑定</h2>

<p>一个switch情况下，可以将其命名为临时常量或变量，在案件的身体使用相匹配的一个或多个值。此行为称为值绑定，因为值绑定到案例正文中的临时常量或变量。</p>

<p>下面的示例采用（x，y）点，表示为类型的元组，并将其分类在下面的图表上：(Int, Int)</p>

<pre><code class="language-text">let anotherPoint = (2, 0)
switch anotherPoint {
case (let x, 0):
    print(&quot;on the x-axis with an x value of \(x)&quot;)
case (0, let y):
    print(&quot;on the y-axis with a y value of \(y)&quot;)
case let (x, y):
    print(&quot;somewhere else at (\(x), \(y))&quot;)
}
// Prints &quot;on the x-axis with an x value of 2&quot;


</code></pre>

<h2 id="toc_19">Switch-where</h2>

<p>一个switch情况下可以使用where子句来检查附加条件。</p>

<p>以下示例对下图中的（x，y）点进行了分类：</p>

<pre><code class="language-text">let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {
case let (x, y) where x == y:
    print(&quot;(\(x), \(y)) is on the line x == y&quot;)
case let (x, y) where x == -y:
    print(&quot;(\(x), \(y)) is on the line x == -y&quot;)
case let (x, y):
    print(&quot;(\(x), \(y)) is just some arbitrary point&quot;)
}
// Prints &quot;(1, -1) is on the line x == -y&quot;
</code></pre>

<h2 id="toc_20">Switch复合案例</h2>

<p>共享相同主体的多个开关盒可以通过case在每个模式之间用逗号后写几个模式来组合。如果任何模式匹配，则认为该情况匹配。如果列表很长，则可以在多行上写入模式。例如：</p>

<pre><code class="language-text">let someCharacter: Character = &quot;e&quot;
switch someCharacter {
case &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;:
    print(&quot;\(someCharacter) is a vowel&quot;)
case &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;,
     &quot;n&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;:
    print(&quot;\(someCharacter) is a consonant&quot;)
default:
    print(&quot;\(someCharacter) is not a vowel or a consonant&quot;)
}
// Prints &quot;e is a vowel&quot;

</code></pre>

<h2 id="toc_21">Switch复合案例包括值绑定</h2>

<p>复合案例的所有模式都必须包含同一组值绑定，并且每个绑定必须从复合案例中的所有模式中获取相同类型的值。这确保了，无论复合案例的哪个部分匹配，案例正文中的代码总是可以访问绑定的值，并且值始终具有相同的类型。</p>

<pre><code class="language-text">let stillAnotherPoint = (9, 0)
switch stillAnotherPoint {
case (let distance, 0), (0, let distance):
    print(&quot;On an axis, \(distance) from the origin&quot;)
default:
    print(&quot;Not on an axis&quot;)
}
// Prints &quot;On an axis, 9 from the origin&quot;
</code></pre>

<h2 id="toc_22">Swift-fallthrough</h2>

<p>在Swift中，switch语句不会落入每个案例的底部并进入下一个案例。也就是说，switch一旦第一个匹配的案例完成，整个语句就完成了它的执行。相反，C要求您break在每个switch案例的末尾插入一个明确的语句，以防止通过。避免默认的下降意味着Swift switch语句比C中的对应语句更简洁和可预测，因此它们避免switch错误地执行多个案例。</p>

<p>如果您需要C样式的直通行为，则可以使用fallthrough关键字逐个选择加入此行为。以下示例fallthrough用于创建数字的文本描述。</p>

<pre><code class="language-text">let integerToDescribe = 5
var description = &quot;The number \(integerToDescribe) is&quot;
switch integerToDescribe {
case 2, 3, 5, 7, 11, 13, 17, 19:
    description += &quot; a prime number, and also&quot;
    fallthrough
default:
    description += &quot; an integer.&quot;
}
print(description)
// Prints &quot;The number 5 is a prime number, and also an integer.&quot;

</code></pre>

<h2 id="toc_23">检查API可用性</h2>

<p>Swift内置支持检查API可用性，这可确保您不会意外使用在给定部署目标上不可用的API。</p>

<p>编译器使用SDK中的可用性信息来验证代码中使用的所有API是否在项目指定的部署目标上可用。如果您尝试使用不可用的API，Swift会在编译时报告错误。</p>

<p>您可以在or 语句中使用可用性条件来有条件地执行代码块，具体取决于您要使用的API是否在运行时可用。当编译器验证该代码块中的API可用时，编译器将使用可用性条件中的信息。ifguard</p>

<pre><code class="language-text">if #available(iOS 10, macOS 10.12, *) {
    // Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS
} else {
    // Fall back to earlier iOS and macOS APIs
}

</code></pre>

<h2 id="toc_24">具有隐含回报的函数</h2>

<p>如果函数的整个主体是单个表达式，则该函数隐式返回该表达式。例如，下面的两个函数都具有相同的行为：</p>

<pre><code class="language-text">func greeting(for person: String) -&gt; String {
    &quot;Hello, &quot; + person + &quot;!&quot;
}
print(greeting(for: &quot;Dave&quot;))
// Prints &quot;Hello, Dave!&quot;

func anotherGreeting(for person: String) -&gt; String {
    return &quot;Hello, &quot; + person + &quot;!&quot;
}
print(anotherGreeting(for: &quot;Dave&quot;))
// Prints &quot;Hello, Dave!&quot;

</code></pre>

<h2 id="toc_25">可变参数</h2>

<p>函数可以具有至多一个可变参数。</p>

<p>可变参数参数接受具有指定类型的零倍或更多的值。您可以使用variadic参数指定在调用函数时可以向参数传递不同数量的输入值。通过...在参数的类型名称后面插入三个句点字符（）来编写可变参数。</p>

<p>传递给可变参数的值在函数体内可用作适当类型的数组。例如，在函数体内可以使用名称numbers和类型的可变参数Double...作为名为numberstype 的常量数组[Double]。</p>

<p>下面的示例计算任意长度的数字列表的算术平均值（也称为平均值）：</p>

<pre><code class="language-text">func arithmeticMean(_ numbers: Double...) -&gt; Double {
    var total: Double = 0
    for number in numbers {
        total += number
    }
    return total / Double(numbers.count)
}
arithmeticMean(1, 2, 3, 4, 5)
// returns 3.0, which is the arithmetic mean of these five numbers
arithmeticMean(3, 8.25, 18.75)
// returns 10.0, which is the arithmetic mean of these three numbers
</code></pre>

<h2 id="toc_26">进出参数</h2>

<p>默认情况下，函数参数是常量。尝试从该函数体内更改函数参数的值会导致编译时错误。这意味着您无法错误地更改参数的值。如果希望函数修改参数的值，并且希望在函数调用结束后这些更改仍然存在，请将该参数定义为输入输出参数。</p>

<p>您只能将变量作为输入输出参数的参数传递。您不能传递常量或文字值作为参数，因为不能修改常量和文字。&amp;当您将变量名称作为参数传递给输入输出参数时，可以将变量名称直接放在变量名称之前，以指示它可以被函数修改。</p>

<p>输入输出参数不能具有默认值，并且不可变参数不能标记为inout。</p>

<p>这是一个名为的函数示例swapTwoInts(_:_:)，它有两个输入输出的整数参数，a并且b：</p>

<pre><code class="language-text">func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>

<p>该swapTwoInts(_:_:)函数简单地交换binto a的值和ainto 的值b。该函数通过将值存储a在一个被调用的临时常量temporaryA，指定bto 的值a，然后分配给它temporaryA来执行此交换b。</p>

<p>您可以swapTwoInts(_:_:)使用两个类型的变量调用该函数Int来交换它们的值。请注意，传递给函数时，someInt和的名称anotherInt前缀为＆符号swapTwoInts(_:_:)：</p>

<pre><code class="language-text">var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;someInt, &amp;anotherInt)
print(&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;)
// Prints &quot;someInt is now 107, and anotherInt is now 3&quot;
</code></pre>

<p>上面的示例显示函数的原始值someInt和anotherInt由swapTwoInts(_:_:)函数修改，即使它们最初是在函数外部定义的。</p>

<p>输入输出参数与从函数返回值不同。swapTwoInts上面的示例没有定义返回类型或返回值，但它仍然修改了someInt和的值anotherInt。输入输出参数是函数在其函数体范围之外产生效果的另一种方法。</p>

<h2 id="toc_27">嵌套函数</h2>

<p>到目前为止，您在本章中遇到的所有函数都是全局函数的示例，这些函数在全局范围内定义。您还可以在其他函数体内定义函数，称为嵌套函数。</p>

<p>默认情况下，嵌套函数对外界是隐藏的，但它们的封闭函数仍然可以调用它们。封闭函数也可以返回其嵌套函数之一，以允许嵌套函数在另一个范围内使用。</p>

<p>您可以重写chooseStepFunction(backward:)上面的示例以使用和返回嵌套函数：</p>

<pre><code class="language-text">func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {
    func stepForward(input: Int) -&gt; Int { return input + 1 }
    func stepBackward(input: Int) -&gt; Int { return input - 1 }
    return backward ? stepBackward : stepForward
}
var currentValue = -4
let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)
// moveNearerToZero now refers to the nested stepForward() function
while currentValue != 0 {
    print(&quot;\(currentValue)... &quot;)
    currentValue = moveNearerToZero(currentValue)
}
print(&quot;zero!&quot;)
// -4...
// -3...
// -2...
// -1...
// zero!

</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16076509804011.html">
                
                  <h1>Masonry布局“Unable to simultaneously satisfy constraints”</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>出现这个问题是设置约束优先级错误，设置一下约束的优先级就行。</p>

<pre><code class="language-text">[self.doctorTitle mas_makeConstraints:^(MASConstraintMaker *make) {
            make.left.equalTo(self.title.mas_left);
            make.right.equalTo(self.title.mas_right);
            make.top.equalTo(self.topline.mas_bottom).offset(10).priorityHigh();
            make.height.mas_equalTo(@14);
}];

</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/12/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_3.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_5.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">










<a target="_blank" class="email" href="mailto:maweefeng@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="%E7%94%B5%E5%BD%B1.html"><strong>电影</strong></a>
        
            <a href="%E5%85%B6%E5%AE%83.html"><strong>其它</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="iOS.html"><strong>iOS</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16076509807659.html">点击事件发生在视图边界之外的时候</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16085259457329.html">MRC 时代的引用计数的现身</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16085257826419.html">自动释放池AutoreleasePool![内存管理-3 2](media/16085257826419/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-3%202.jpg)</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16076509804045.html">RACCommand</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16076509806399.html">Localization Issue Warning Storyboard</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
